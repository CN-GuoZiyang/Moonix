# RISC-V 汇编

本章将简明地介绍 RISC-V 平台的汇编，并在最后给出 C 语言内联汇编的内容。

## RISC-V 寄存器

RISC-V 架构中包含了 32 个整数寄存器，如下：

|寄存器|ABI 名称|描述|函数调用时保存|
|:-:|:-:|:-:|:-:|
|x0|zero|硬件零|——|
|x1|ra|调用结束后的返回地址|调用者|
|x2|sp|栈顶指针|被调用者|
|x3|gp|全局指针|——|
|x4|tp|线程指针|——|
|x5-7|t0-2|临时寄存器|调用者|
|x8-9|s0-1|被调用者保存寄存器|被调用者|
|x10-17|a0-7|调用参数|调用者保存|
|x18-27|s2-11|被调用者保存寄存器|被调用者|
|x28-31|t3-6|临时寄存器|调用者|

RISC-V 将一些寄存器保留作特定的用途，这里可以从 ABI 名称中推测出来。例如：以 `t` 开头的寄存器表示临时寄存器，可以被用于任何用途；以 `a` 开头的寄存器用于向函数传递参数；以 `s` 开头的寄存器（sp 除外）将在过程调用过程中不被修改。

## 整数指令

RISC-V 指令集包含了整数指令、逻辑指令以及一些内存指令。RISC-V 架构是一个Load / Store 架构，所以整型指令操作数必须是寄存器。

|指令示例|描述|
|:-:|:-:|
|`lb t0, 8(sp)`|将内存地址 sp+8 处的值加载（解引用）到寄存器 t0 中。lb 加载一个字节，lh 加载半字，lw 加载一个字，ld 加载双字 |
|`sb t0, 8(sp)`|将寄存器 t0 的值存储（解引用）到内存地址 sp + 8 处，sb 存储一个字节，sh 存储半字，sw 存储一个字，sd 存储双字|
|`add a0, t0, t1`|将 t0 和 t1 的值相加，结果存储在 a0 中|
|`addi a0, t0, -10`|将 t0 的值与 -10 相加，结果存储在 a0 中|
|`sub a0, t0, t1`|t0 的值减去 t1 的值，结果存储在 a0 中|
|`mul a0, t0, t1`|将 t0 的值与 t1 的值相乘，结果存储在 a0 中|
|`div a1, s3, t3`|s3 的值除以 t3 的值，结果存储在 a1 中|
|`rem a1, s3, t3`|s3 的值除以 t3 的值，余数存储在 a1 中|
|`and a3, t3, s3`|将 t3 和 s3 的值做与运算，结果存储在 a3 中|
|`or a3, t3, s3`|将 t3 和 s3 的值做或运算，结果存储在 a3 中|
|`xor a3, t3, s3`|将 t3 和 s3 的值做异或运算，结果存储在 a3 中|

由于 RISC-V 是一个精简指令集架构，删除了很多能用已有指令实现的指令。例如，指令 `neg a0, a1` 不存在，因为这和 `sub a0, zero, a1` 等价。换句话说，`0-a1` 和 `-a1` 等价。

## 伪指令

RISC-V 汇编器还提供了很多伪指令，这些指令会由汇编器转换为真正存在的指令。例如，上面提到的 `neg` 就是一个伪指令。当汇编器解析到该条指令时，就会自动地将其转换为 `sub` 指令。以下是伪指令和其功能。

![pseudo1](https://cn-guoziyang.gitee.io/moonix/assets/img/pseudo1.png)

![pseudo2](https://cn-guoziyang.gitee.io/moonix/assets/img/pseudo2.png)

## 分支指令

分支指令用来跳转到代码的不同部分。如果没有分支指令，CPU 就只能一条指令接着一条指令按顺序执行。有了跳转和分支，我们就可以转移到任何指令处。

分支指令用来在汇编层面实现函数调用和条件转移。分支的意思就是“条件跳转”指令，例如 `beq, bne, bgt, bge, blt, ble`，它们的意思分别是如果相等、不相等、大于、大于等于、小于、小于等于的情况下就跳转。

分支指令有三个参数：要比较的两个操作数（寄存器），如果比较为真，则是要执行的指令的内存标签。如果分支条件为 false，则忽略分支指令，CPU执行下一条指令。

```c
# t0 = 0
li      t0, 0
li      t2, 10
loop_head:
bge     t0, t2, loop_end
# Repeated code goes here
addi    t0, t0, 1
j		loop_head
loop_end:
```

上面的这段汇编代码等价于以下的循环：

```c
int i = 0;
for(i = 0; i < 10; i ++)
{
    // Repeated code goes here
}
```

注意在汇编中，我使用了这个条件的相反条件。for 循环中，只要条件为真，就会执行循环体，而在汇编中，如果 t0 大于等于 t2，就跳出循环。这种方式可以节省一些寄存器。

## 使用栈

栈用于本地内存存储。栈从底部（高内存）向顶部（低内存）增长。栈底部有一个专门的寄存器 sp 记录，这个寄存器又被称为栈指针。

我们使用被调用者保存寄存器时，或者我们想在函数调用过程中保存一个临时寄存器，我们就必须将它们保存在栈上。从栈上分配空间，我们需要将 sp 减去一个值。从栈上回收空间，我们需要将 sp 加上一个值。注意我们没有“清理”栈空间，这就是为什么 C 语言中不能直接使用未初始化的局部变量。

栈必须对齐到 8 字节边界，这意味着我们只能分配或回收 8 字节倍数的内存。

```c
addi    sp, sp, -8
sd      ra, 0(sp)
call    printf
ld      ra, 0(sp)
addi    sp, sp, 8
ret
```

上面的代码将返回地址保存在栈上，然后调用 printf。当 printf 返回时，我们从堆栈中加载返回地址的旧值，然后通过 sp 加 8 的方式来释放栈内存。

## C 语言到汇编的转换

编译器的工作是将 .c 文件转换成汇编文件，汇编器则是将汇编文件作为目标文件汇编成机器码。然后，链接器就会将所有的目标文件链接到一个可执行文件中。

C 语言代码可以归结为汇编，这意味着我们用 C 语言做的事情，也可以用汇编做。上面已经展示了 for 循环的例子，我们来看看其他结构。

## 函数

函数在汇编中，仅仅是函数第一条指令的内存标签。应用程序二进制接口（ABI）指定哪些寄存器获得哪些参数，以及如何来回返回内容。然而，所有的函数都有一个开场白（Prologue，实质上是为本地存储设置一个栈帧）和一个结语（Epilogue，通常需要加载保存的寄存器和返回地址，并在返回之前移动栈指针）。

```c
void my_function();
```

```c
my_function:
    # Prologue
    addi    sp, sp, -32
    sd      ra, 0(sp)
    sd      a0, 8(sp)
    sd      s0, 16(sp)
    sd      s1, 24(sp)

    # Epilogue
    ld      ra, 0(sp)
    ld      a0, 8(sp)
    ld      s0, 16(sp)
    ld      s1, 24(sp)
    addi    sp, sp, 32
    ret
```

以上代码代码首先从栈中分配 32 字节，即 4 个寄存器的大小。首先从 sp 减去所有必要空间的大小，将值存储在栈上，运行代码，最后执行 epilogue。这就是为 store 和 load 指令添加偏移量的主要目的。

另一件需要注意的事是，我存储了所有调用者保存的寄存器。同样的，我们还必须考虑所有的调用者保存的寄存器会被重置，这包括来所有的临时寄存器、参数寄存器和返回地址寄存器。我确实在上面保存了一些被调用者保存的寄存器，但是回想一下，如果我们使用被调用者保存的寄存器，我们需要在函数返回之前恢复它们的原始值。

我们需要一个开场白和一个结语。在编程语言的课程中，你们应当学过栈桢。因此，我们需要手动为函数分配所有它需要的空间，并将数据保存进去。

```c
bne     t0, zero, 1f
# Code goes here if t0 == 0
j       2f
1:
bne     t1, zero, 1f
# Code goes here if t1 == 0
j       2f
1:
# Code goes here if t0 != 0 and t1 != 0
2:
# Dumping point is here.
```

上面的汇编代码等价于下面的 C 代码。

```c
if (!t0) 
{
    // Code goes here if t0 == 0
}
else if (!t1) 
{
    // Code goes here if t1 == 0
}
else 
{
    // Code goes here if t0 != 0 and t1 != 0
}
// Dumping point is here.
```

标签 `1f` 表示转移到当前位置之前的标签 1 处，这和标签 `1b` 相反，它表示转移到当前位置之后的标签 1 处。

## 调用 `Printf`

Printf 要求第一个参数是一个 c 风格的、以空字符结尾的字符串，我们可以使用 `.asciz` 汇编指令创建它。下面的代码给出了一个如何使用 printf 的示例。

```c
.section .rodata
prompt: .asciz "Value of t0 = %ld and value of t1 = %ld\n"
.section .text
myfunc:
    addi    sp, sp, -8
    sd      ra, 0(sp)
    la      a0, prompt
    mv      a1, t0
    mv      a2, t1
    call    printf
    ld      ra, 0(sp)
    addi    sp, sp, 8
    ret
```

上面的代码中，我们将 printf 的第一个参数放入 a0 中，这是我们想要输出的字符串。然后我们想输出 t0 和 t1 的值，所以它们需要分别存储到参数寄存器 a1 和 a2 中。

任何时候看到函数调用，都应该考虑保存返回地址寄存器，就像上面所做的那样。

## 应用程序二进制接口（ABI）

我们有 8 个参数寄存器 a0 到 a7，这将是传递给函数的 8 个非浮点数参数。参数可能是指针，这种情况下 aX 将包含一个内存地址，或者直接传递数值，这时 aX 将包含实际的值。

ABI 进一步要求，我们必须通过 a0 返回一个整数值作为返回值。

## C 语言内联汇编

汇编语言用作多种用途，例如提高程序的速度，减少内存需求和控制硬件。使用内联汇编程序，在没有额外汇编程序和链接步骤的情况下，就可直接在 C 源程序中嵌入汇编语言指令。其中示例以 AT&T/UNIX 语法为例。

### 基本内联

基本内联汇编的格式非常直接了当。它的基本格式为：`asm("汇编代码")`。

例如：

```c
asm ("movl %ecx %eax");  /* 将 ecx 寄存器的内容移至 eax */
asm ("movb %bh (%eax)"); /* 将 bh 的一个字节数据 移至 eax 寄存器指向的内存 */
```

`asm` 和 `__asm__` 这两个关键字都是有效到，设立两个关键字主要是为了防止标识符冲突。如果汇编指令多于一条，可以每个指令一行，并用双引号圈起，同时为每条指令添加 '\n' 和 '\t' 后缀。gcc 会通过使用换行符或制表符发送正确格式化后的行给汇编器。

例如：

```c
asm ("movl %eax, %ebx\n\t"
     "movl $56, %esi\n\t"
     "movl %ecx, $label(%edx,%ebx,$4)\n\t"
     "movb %ah, (%ebx)");
```

### 扩展汇编

在基本内联汇编中，我们只能直接书写指令。而在扩展汇编中，我们可以同时指定操作数。扩展汇编允许我们指定输入寄存器、输出寄存器以及修饰寄存器列表。扩展汇编基本格式为：

```c
asm ( 汇编程序模板
: 输出操作数 /* 可选的 */
: 输入操作数 /* 可选的 */
: 修饰寄存器列表 /* 可选的 */
);
```

汇编程序模板由汇编指令组成。每一个操作数由一个操作数约束字符串所描述，其后紧接一个括弧括起的 C 语言表达式。 冒号用于将汇编程序模板和第一个输出操作数分开，另一个（冒号）用于将最后一个输出操作数和第一个输入操作数分开（如果存在的话）。 逗号用于分离每一个组内的操作数。总操作数的数目限制在 10 个，或者机器描述中的任何指令格式中的最大操作数数目，以较大者为准。 如果没有输出操作数但存在输入操作数，你必须将两个连续的冒号放置于输出操作数原本会放置的地方周围。

示例代码：

```c
asm ("cld\n\t"
     "rep\n\t"
     "stosl"
    :                                       /* 无输出 */
    :"c"(count), "a"(fill_value), "D"(dest) /* 输入列表 */
    :"%ecx", "%edi"                         /* 修饰寄存器列表 */
    );
```

以上的内联汇编是将 `fill_value` 的值连续 `count` 次拷贝到寄存器 `edi` 所指位置（每执行 `stosl` 一次，寄存器 `edi` 的值会递增或递减，这取决于是否设置了 `direction` 标志，因此以上代码实则初始化一个内存块）。 它也告诉 GCC 寄存器 `ecx` 和 `edi` 一直无效。

为了更加清晰地说明，让我们再看一个示例：

```c
int a=10, b;
asm ("movl %1, %%eax;
      movl %%eax, %0;"
    :"=r"(b)        /* 输出列表 */
    :"r"(a)         /* 输入列表 */
    :"%eax"         /* 修饰寄存器列表 */
    );
```

这个示例的作用是使用汇编指令使变量 `b` 的值等于变量 `a` 的值。其中：

- `b` 为输出操作数，用 `%0` 引用，`a` 为输入操作数，用 `%1` 引用。
- `"r"` 和 `"=r"` 为操作数约束字符串。之后会更详细地介绍约束。 这里 `r` 告诉 GCC 可以使用任一寄存器存储操作数。输出操作数约束应该有一个约束修饰符 `=`，表明它是一个只读的输出操作数。
- 寄存器名字以两个 `%` 为前缀。这有利于 GCC 区分操作数和寄存器。操作数以一个 `%` 为前缀。
- 第三个冒号之后的修饰寄存器 `%eax` 用于告诉 GCC `%eax` 的值将会在 asm 内部被修改，所以 GCC 将不会使用此寄存器存储任何其他值。

### 汇编程序模板

汇编程序模板包含了被插入到 C 语言程序的汇编指令集。
其格式为：每条指令用双引号圈起，或者整个指令组用双引号圈起。
同时每条指令应以分界符结尾。有效的分界符有换行符 `\n` 和分号 `;`，`\n` 可以紧随一个制表符 `\t`。

### 输入操作数和输出操作数

扩展汇编的每个操作数是一个用括弧圈起的 C 语言表达式，前面是以双引号圈起的操作数约束字符串。约束字符串主要用于决定操作数的寻址方式，同时也用于指定使用的寄存器。

当操作数多于一个时，用逗号隔开。

每个操作数在汇编程序模板中用数字引用。编号方式索引初始值为 `0`。操作数的最大个数在前一节介绍过。

输出操作数表达式必须为左值。输入操作数的要求不像这样严格。它们可以为表达式。
扩展汇编特性常常用于编译器所不知道的机器指令。如果输出表达式无法直接寻址（即它是一个位域），我们的约束字符串必须给定一个寄存器。
在这种情况下，GCC 将会使用该寄存器作为汇编的输出，然后存储该寄存器的内容到输出。

正如前面所陈述的一样，普通的输出操作数必须为只写的； GCC 将会假设指令前的操作数值是死的，并且不需要被（提前）生成。扩展汇编也支持输入-输出或者读-写操作数。

以下为另一个示例代码。目的是求一个数的5次方结果。为了计算该值，使用了 `lea` 指令。

```c
asm ("leal (%1,%1,4), %0"
    :"=r"(five_times_x)
    :"r"(x)
    );
```

这里输入为 `x`。不指定使用的寄存器，GCC 将会自己选择一些输入寄存器，一个输出寄存器。
如果想要输入和输出放在同一个寄存器里，可以通过指定合适的约束来实现它。示例代码：

```c
asm ("leal (%0,%0,4), %0"
    :"=r"(five_times_x)
    :"0"(x)
    );
```

现在输出和输出操作数位于同一个寄存器。但是无法得知是哪一个寄存器。
以下是另一种方法指定操作数所在的寄存器。示例代码：

```c
asm ("leal (%%ecx,%%ecx,4), %%ecx"
    :"=c"(x)
    :"c"(x)
    );
```

在以上三个示例中，我们并没有在修饰寄存器列表里添加任何寄存器，为什么？
在头两个示例， GCC 决定了寄存器并且它知道发生了什么改变。
在最后一个示例，我们不必将 `ecx` 添加到修饰寄存器列表。因为 GCC 已经知道它表示 `x`，它就不用被当作修饰的（寄存器）了。

### 修饰寄存器列表

一些指令会修改一些硬件寄存器内容。我们不得不在修饰寄存器列表中列出这些寄存器，即扩展汇编内第三个 `:` 之后的部分。
这可以告知 GCC 汇编指令将会使用和修改这些寄存器，这样 GCC 就不会假设存入这些寄存器的值是有效的。
不用在这个列表里列出输入、输出寄存器。因为它们被显式地指定了约束，GCC 可以推断 `asm` 使用了它们。
如果指令隐式或显式地使用了任何除此之外的其他寄存器，那么就需要在修饰寄存器列表中指定这些寄存器。

如果指令会修改 条件码寄存器（Condition Code Register）（又称状态寄存器或标志寄存器），则必须将 `%cc` 添加进修饰寄存器列表。

如果我们的指令以不可预测的方式修改了内存，那么需要将 `memory` 添加进修饰寄存器列表。
这可以使 GCC 不会在汇编指令间保持缓存于寄存器的内存值。如果被影响的内存不在汇编的输入或输出列表中，我们也必须添加 `volatile` 关键词。

我们可以按我们的需求多次读写修饰寄存器。参考一下模板内的多指令示例；它假设子例程 `_foo` 接受寄存器 `eax` 和 `ecx` 里的参数。

```c
asm ("movl %0,%%eax;
      movl %1,%%ecx;
      call _foo"
    : /* no outputs */
    :"g"(from), "g"(to)
    :"eax", "ecx"
    );
```

### 关于 `volatile`

如果汇编语句必须在我们放置它的地方执行（例如，不能为了优化而被移出循环语句），将 C 语言标准的关键词 `volatile` 放置在 `asm` 后面、`()` 的前面。
以避免编译器不可预知的优化，防止它被移动、删除或者其他操作。内核源码经常会有这种写法。

```c
asm volatile ( 汇编程序模板
             : 输出操作数     /* 可选的 */
             : 输入操作数     /* 可选的 */
             : 修饰寄存器列表  /* 可选的 */
             );
```

类似于 `__asm__`，`__volatile__` 是 `volatile` 的别名，可以避免 `volatile` 与其它标识符冲突。

### 关于操作数约束字符串

约束和内联汇编有很大的关联。但以上对约束的介绍还不多。约束用于表明

- 操作数是否可以位于寄存器和位于哪种寄存器
- 操作数是否可以是一个内存引用和哪种地址
- 操作数是否可以是一个立即数和可能的取值范围，等等

#### 常用约束

1. 寄存器操作数约束 `r`

    当使用这种约束指定操作数时，它们存储在通用寄存器中。示例代码：

    ```c
    asm ("movl %%eax, %0\n" :"=r"(myval));
    ```

    变量 `myval` 保存在寄存器中，寄存器 `eax` 的值被复制到该寄存器中，然后 `myval` 的值从寄存器更新到了内存。

    还可以指定其它特定的寄存器。它们为：

    | r | Register(s)      |
    | :-- | :----------------- |
    | `a` | `%eax` `%ax` `%al` |
    | `b` | `%ebx` `%bx` `%bl` |
    | `c` | `%ecx` `%cx` `%cl` |
    | `d` | `%edx` `%dx` `%dl` |
    | `S` | `%esi` `%si`       |
    | `D` | `%edi` `%di`       |

2. 内存操作数约束 `m`

    `m` 约束允许一个内存操作数，可以使用机器普遍支持的任一种地址。
    当操作数位于内存时，任何对它们的操作将直接发生在内存位置，这与寄存器约束相反，后者首先将值存储在要修改的寄存器中，然后将它写回到内存位置。
    但寄存器约束通常用于一个指令必须使用它们或者它们可以大大提高处理速度的地方。
    当需要在 `asm` 内直接更新一个 C 变量，而又不想使用寄存器去保存它的值，使用内存最为有效。例如，将 IDTR 寄存器的值存储于内存位置 loc 处：

    ```c
    asm ("sidt %0\n" : :"m"(loc));
    ```

3. 匹配（数字）约束

    在某些情况下，一个变量可能既充当输入操作数，又充当输出操作数。可以通过使用匹配约束在 `asm 中指定这种情况。示例代码：

    ```c
    asm ("incl %0" :"=a"(var):"0"(var));
    ```

    这个匹配约束的示例中，寄存器 `%eax` 既用作输入变量，也用作输出变量。 `var` 输入被读进 `%eax`，并且等递增后更新的 `%eax` 再次被存储进 `var`。
    这里的 `0` 用于指定与第 `0` 个输出变量相同的约束。该约束可用于：

    - 在输入从变量读取或变量修改后且修改被写回同一变量的情况
    - 在不需要将输入操作数实例和输出操作数实例分开的情况

    使用匹配约束最重要的意义在于它们可以有效地使用可用寄存器。

4. 一些其它通用约束

    - `o` 约束：允许一个内存操作数，但只有当地址是可偏移的时。即，该地址加上一个小的偏移量可以得到一个有效地址
    - `V` 约束：一个不允许偏移的内存操作数。换言之，任何适合 "m" 约束而不适合 "o" 约束的操作数
    - `i` 约束：允许一个（带有常量）的立即整形操作数，这包括其值仅在汇编时期知道的符号常量
    - `n` 约束：允许一个带有已知数字的立即整形操作数。许多系统不支持汇编时期的常量，因为操作数少于一个字宽。对于此种操作数，约束应该使用 `n` 而不是 `i`
    - `g` 约束：允许任一寄存器、内存或者立即整形操作数，不包括通用寄存器之外的寄存器

#### 约束修饰符

当使用约束时，对于更精确的控制超过了对约束作用的需求，GCC 给我们提供了约束修饰符。最常用的约束修饰符为：

- `=` 约束修饰符：意味着对于这条指令，操作数为只写的，旧值会被忽略并被输出数据所替换
- `&` 约束修饰符：意味着这个操作数为一个早期改动的操作数，其在该指令完成前通过使用输入操作数被修改了。
  因此，这个操作数不可以位于一个被用作输出操作数或任何内存地址部分的寄存器。
  如果在旧值被写入之前它仅用作输入而已，一个输入操作数可以为一个早期改动操作数。