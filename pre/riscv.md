# RISC-V 硬件机制

本章主要介绍 RISC-V 的相关硬件机制，基于 RV64，SBI 相关机制基于 SBI 标准 v0.2。SBI 实现以 OpenSBI 为例。

## 概览

> RISC-V（发音为“risk-five”）是一个基于精简指令集（RISC）原则的开源指令集架构（ISA），简易解释为开源软件运动相对应的一种“开源硬件”。该项目2010年始于加州大学柏克莱分校，但许多贡献者是该大学以外的志愿者和行业工作者。

RISC-V 是一个典型的 `Load-Store` 类型的指令集架构，这意味着几乎所有的指令的操作数都只能是立即数或者寄存器，而不能是某个内存地址。如果想要修改内存某处的值，只能通过 `Load` 指令将某个内存地址处的值加载到寄存器中，并在修改完成后通过 `Store` 指令将其写入内存。

为了保证架构的可扩展性，RISC-V 采用了模块化设计，包括几个可以互相替换的基本指令集,　以及额外可以选择的扩展指令集。本章及其后的内容将基于 RV64I，并且不会涉及扩展指令集。

## 特权等级

任何时候，RISC-V 硬件线程（*hart*）都运行在某个特权等级下，这些特权级由一个或者多个控制寄存器（*CSR*）编码表示。目前标准定义的三个特权级如下表：

|等级|编码|名称|简写|
|:-:|:-:|:-:|:-:|
|0|00|用户/应用程序（User/Application）|U|
|1|01|监管者（Supervisor）|S|
|2|10|*未定义*||
|3|11|机器（Machine）|M|

特权等级用于在软件堆栈的不同组件之间提供保护，如果试图执行当前特权模式不允许的操作，将引发异常。这些异常通常会导致自陷以进入底层执行环境进行处理。

机器模式拥有最高的特权，并且是 RISC-V 硬件平台唯一强制实现的特权级别。运行在机器模式（M-Mode）中的代码应当是受信任的，因为它对机器实现有低层访问。M-Mode 可以用来管理RISC-V上的安全执行环境。用户模式（U-Mode）和监管者模式（S-Mode）分别用于传统的应用程序和操作系统。

具体的实现可以以降低隔离程度来换取更低的实现成本，三种经典的实现如下表：

|特权等级个数|支持的模式|设计用途|
|:-:|:-:|:-:|
|1|M|简单的嵌入式系统|
|2|M, U|安全的嵌入式系统|
|3|M, S, U|运行 Unix-Like 操作系统|

所有的硬件实现都必须提供 M-Mode，因为这是唯一可以自由访问整个机器的模式。最简单的 RISC-V 实现可能只提供 M-Mode，但这种实现不会对系统提供保护以防止错误或是恶意的应用程序代码。

许多 RISC-V 实现还将至少支持用户模式（U-Mode），以保护系统的其余部分不受应用程序代码的影响。系统实现还可以添加监管者模式（S-Mode），以隔离监管者级操作系统和监管者执行环境（SEE）。

hart 通常在 U-Mode 下运行应用程序代码，直到某些陷阱（例如监管者调用或时钟中断）使得切换到陷阱处理程序（通常特权级更高）。hart 会执行陷阱处理程序，这个陷阱处理程序最终会在 U-Mode 中导致陷阱的指令处或之后恢复执行。提高权限级别的陷阱称为垂直陷阱，而保持在相同权限级别的陷阱称为水平陷阱。垂直陷阱可以在较低特权模式下将控制权返回给水平陷阱处理程序以实现水平陷阱。

## 寄存器组

### 通用寄存器

通用寄存器为 RV64I 指令子集中规定的通用寄存器，虽名为“通用”寄存器，但在 ABI（应用程序二进制接口）中仍然赋予了其中一些寄存器以特殊的含义，以保证编码的统一性。

这些寄存器如下：

|寄存器|ABI 名称|描述|函数调用时保存|
|:-:|:-:|:-:|:-:|
|x0|zero|硬件零|——|
|x1|ra|调用结束后的返回地址|调用者|
|x2|sp|栈顶指针|被调用者|
|x3|gp|全局指针|——|
|x4|tp|线程指针|——|
|x5-7|t0-2|临时寄存器|调用者|
|x8-9|s0-1|被调用者保存寄存器|被调用者|
|x10-17|a0-7|调用参数|调用者保存|
|x18-27|s2-11|被调用者保存寄存器|被调用者|
|x28-31|t3-6|临时寄存器|调用者|

其中 x10（a0）和 x11（a1）在函数调用过程中也用于保存返回值。

#### 函数调用规范

函数调用规范（Calling Convention）是在函数调用发生时，传递参数和返回值的方式的约定。这些约定将由编译器实现。下面仅描述整数调用约定，变量 `XLEN` 指指令集位宽，在 RV64 中该值为 64，RV32 中为 32。

基本的整数调用约定提供了 8 个参数寄存器 a0 ~ a7，前两个寄存器也用于保存返回值。

单个参数寄存器中最多存储 `XLEN` 位宽的数据，如果没有可用的寄存器，那么参数就会被保存在栈上。当将参数存储到寄存器或是栈上时，小于 `XLEN` 位的整数会根据其类型扩展到 32 位，接着再符号扩展到 `XLEN` 位。

单个长度为 `2*XLEN` 参数会存储在一对参数寄存器中，其中低 `XLEN` 位存储在编号较小的寄存器中，高 `XLEN` 位存储在编号较大的寄存器。如果没有可用的寄存器，那么参数就会被保存在栈上，如果恰好只有一个寄存器可用，那么低 `XLEN` 位会保存在寄存器上而高 `XLEN` 位会保存在栈上。

宽度超过 `2*XLEN` 位的参数会以引用的方式传递。

当一个聚合体（如数组或者结构体等）作为一个参数传递时，如果其大小不超过 `XLEN` 位，会直接通过参数寄存器传递，其中字段的布局和在内存中相同。如果没有可用的寄存器，聚合体就会通过栈传递。如果聚合体的总大小不超过 `2*XLEN` 位，该聚合体会通过一对寄存器传递；如果只有一个寄存器可用，那么这个聚合体的前半部分会保存在寄存器中，而后一半会保存在栈上。用于对齐填充的位，以及超过聚合体的末尾且其大小不能被 `XLEN` 整除的位，其行为是未定义的，由编译器实现。

由栈传递的聚合体或是整数会对齐到类型对齐要求或是 `XLEN` 中较大的一个，但是不会超过栈的对齐要求。

位字段以小端序存储。如果某个位字段超出了其整数类型的边界，将填充空余的位到下一个对齐边界。

所有通过引用传递的参数可以被被调用者修改。

在基本的整数调用约定中，可变参数的传递方式和命名参数相同，但是由一个例外情况。以 `2*XLEN` 位对齐且大小最多为 `2*XLEN` 位的可变参数通过一对参数寄存器传递，或者在没有寄存器可用的情况下通过栈传递。当一个可变参数被通过栈传递后，所有后续的参数也都会通过栈传递（例如，最后一个参数寄存器可能由于对齐原因未被使用）。

返回值的传递方式和传递第一个命名参数的方式相同。如果这样的参数是以引用方式传递的，则由调用者为返回值分配内存，并将其地址作为隐式的第一个参数传递。

栈向下增长（向低地址方向），栈顶指针在过程（函数）入口应当对齐到 128 位边界。在函数入口处传递的第一个参数应当位于栈顶指针偏移量为 0 处，后续的参数依次存储在**更高**的地址中。

### 控制寄存器

标准 RISC-V 指令集使用 12 位编码空间来编码控制寄存器（CSR），使得指令集最多支持 4096 个控制寄存器。具体的控制寄存器的作用会在使用时讲解。控制寄存器只有特殊的指令才可以读写，这些指令都是原子指令。

- `csrrw dst, csr, src`<br>
    先将 csr 的值写入 dst，并将 src 的值写入 csr

- `csrr dst, csr`<br>
    将 csr 的值读到 dst

- `csrw csr, src`<br>
    将 src 的值写入 csr

- `csrc(i) csr, rs1`<br>
    将 csr 中指定的位清零，csrc 使用通用寄存器作为 mask，csrci 则使用立即数。

- `csrs(i) csr, rs1`<br>
    将 csr 中指定的位置 1，csrc 使用通用寄存器作为 mask，csrci 则使用立即数。

## 中断机制

微观上，我们使用*异常*来表示当前硬件线程中执行代码发生的特殊情况，而*中断*则表示一个外部的异步事件，这个事件可能引起控制转移，通常与当前执行代码无关。宏观上，我们将其统称为*中断*。

### 全局中断使能

mstatus 寄存器记录了当前硬件线程的状态，由多个状态位组成。mstatus 寄存器在 S-Mode 和 U-Mode 中分别以 sstatus 和 ustatus 的名称被访问，事实上它们都是同一个寄存器的不同视图，高权限级的视图可以访问更多的状态位，低权限级低视图只能访问受限的位。

![mstatus](https://cn-guoziyang.gitee.io/moonix/assets/img/mstatus.png)

mstatus 寄存器中，MIE、SIE 和 UIE，分别是不同权限等级的全局中断使能位。当硬件线程以 x-Mode 运行时，xIE=1 时全局启用中断，xIE=0 时全局禁用中断，全局启用中断意味着，在该模式下运行的线程会被中断打断，并进入到中断处理流程中。

如果 xIE=1，低特权级 w 的中断会被全局禁用，无论是否设置 wIE 位。类似，高特权级 y 的中断会被全局启用，无论是否设置 yIE 位。高权限级代码可以使用单独的中断启用位来禁用选定的高权限模式中断，然后将控制权让与低权限模式。

为了支持嵌套中断处理，每个特权模式 x 都有两套中断启用位和特权级。xPIE 位存储了中断处理发生前的中断使能位的值，xPP 存储了上一个特权模式。由于 xPP 字段只能存储高于 x 的特权模式，所以 MPP 是两位宽，SPP 是一位宽，而 UPP 隐式为 0 。当中断处理从特权模式 y 进入特权模式 x 时，xPIE 被设置为 xIE 的值，xIE 被设置为 0，xPP 被设置为 y。

指令 `MRET`、`SRET` 和 `URET` 分别用于从 M-Mode、S-Mode 和 U-Mode 的中断处理中返回。当执行 `xRET` 指令时，假设 xPP 寄存器中的值为 y，那么 xIE 会被设置为 xPIE 的值，特权模式会变为 y，xPIE 会被设置为 1，xPP 会被设置为 U（如果系统不支持 U-Mode 则会设置为 M）。

xPP 字段是 **WARL**（Write any values, read legal values）字段，只能保存低于或等于 x 的特权模式，如果系统没有实现 x 模式，xPP 必须被硬连接到 0。

### 具体类型中断使能

具体类型的中断使能设置涉及了一对寄存器：mip 和 mie，这对寄存器在 S-Mode 和 U-Mode 下同样也有一对受限的视图，sip/sie 和 uip/uie。mip 中存储了未决中断（pending interrupts）的相关信息，而 mie 中存储了具体类型的中断使能信息。

![mip](https://cn-guoziyang.gitee.io/moonix/assets/img/mip.png)

![mie](https://cn-guoziyang.gitee.io/moonix/assets/img/mie.png)

MTIP、STIP、UTIP 位分别对应于 M-Mode、S-Mode 和 U-Mode 时钟中断的时钟中断位决位。MTIP 位是只读的，只能通过写入内存映射的 M-Mode 时钟比较寄存器来清除。UTIP 和 STIP 位可以被 M-Mode 代码修改，用来设置低权限级的时钟中断。

对于不同模式的时钟中断，mie 中分别有一个时钟中断使能位：MTIE、STIE 和 UTIE。

软件中断和外部中断与时钟中断类似。

只有 mip 和 mie 中的位 i（i 指时钟、软件或外部中断）被设置为 1，且全局启用了中断，才能启用 i 中断。默认情况下，如果硬件线程的当前特权模式低于 M 模式，或者当前特权模式是 M 且 mstatus 寄存器中的 MIE 位置为 1，M-Mode 的中断就是全局启用的。

不同权限模式的多个并发中断按照权限模式递减的顺序进行处理，同一个特权模式下的多个并发中断按照以下优先级递减顺序处理：MEI、MSI、MTI、SEI、SSI、STI、UEI、USI、UTI。同步异常的优先级低于所有异步中断。

### 中断处理程序

此处中断处理程序以 M-Mode 为例，涉及的寄存器只需要更换寄存器名前缀即可推广到不同的特权模式。

当 M-Mode 异常或是中断发生时，如果开始了对应类别的中断，并且全局使能中断，那么当前硬件线程的执行流程会被打断，控制转移到中断处理程序。mtvec 寄存器配置控制转移过程，该寄存器由一个向量基地址（BASE）和向量模式（MODE）组成。

![mtvec](https://cn-guoziyang.gitee.io/moonix/assets/img/mtvec.png)

BASE 字段的值必须至少对齐 4 字节边界，MODE 的设置可能对 BASE 字段的对齐模式增加更严格的对齐限制。

|MODE 值|名称|描述|
|:-:|:-:|:-:|
|0|Direct|所有的中断发生时，都会跳转到 BASE 处|
|1|Vectored|异步中断发生时，pc 会被设置为 `BASE+4×cause`|
|>=2|——|*保留*|

由上表，当 MODE 为 Direct 时，所有进入 M-Mode 的中断都会导致 pc 被设置为 BASE 字段中的地址。当 MODE 为 Vectored 时，所有进入 M-Mode 的同步异常都会导致 pc 被设置为 BASE 字段中的地址，而异步中断则会导致 pc 被设置为 BASE 字段中的地址加上中断原因编码的四倍。例如，当一个 M-Mode 的时钟中断发生时，pc 会被设置为 `BASE+0x1c`。中断原因编码会在讲述 xcause 寄存器时讲解。

### 中断信息

当某个中断发生时，硬件会自动填写一些寄存器以辅助中断处理程序处理中断。这里以 M-Mode 下的寄存器为例，其他特权模式下的寄存器只需要更换特权前缀即可。

当控制转移到 M-Mode 中时，mcause（Machine Cause Register）寄存器会被自动填入代表中断类型的代码。

![mcause](https://cn-guoziyang.gitee.io/moonix/assets/img/mcause.png)

如果控制转移是由一个异步中断导致的，mcause 中的 Interrupt 位会被置为 1。Exception Code 字段存储了最后一个发生的异常或中断的代码。代码如下：

|Interrupt|Exception Code|描述|
|:-:|:-:|:-:|
|1|0|U-Mode 软件中断|
|1|1|S-Mode 软件中断|
|1|3|M-Mode 软件中断|
|1|4|U-Mode 时钟中断|
|1|5|S-Mode 时钟中断|
|1|7|M-Mode 时钟中断|
|1|8|U-Mode 外部中断|
|1|9|S-Mode 外部中断|
|1|11|M-Mode 外部中断|
|0|0|指令地址未对齐|
|0|1|指令访问故障|
|0|2|非法的指令|
|0|3|断点|
|0|4|Load 地址未对齐|
|0|5|Load 访问故障|
|0|6|Store/AMO 地址未对齐|
|0|7|Store/AMO 访问故障|
|0|8|来自 U-Mode 的环境调用|
|0|9|来自 S-Mode 的环境调用|
|0|11|来自 M-Mode 的环境调用|
|0|12|指令页故障|
|0|13|Load 页故障|
|0|15|Store/AMO 页故障|

如果单条指令导致了多个同步异常，下面的优先级表决定了 mcause 展示哪个异常。

|优先级|异常代码|描述|
|:-:|:-:|:-:|
|*最高*|3|指令地址断点|
||12|指令页故障|
||1|指令访问故障|
||2|非法指令|
||0|指令地址未对齐|
||8, 9, 11|环境调用|
||3|环境断点|
||3|Load/Store/AMO 地址断点|
||6|Store/AMO 地址未对齐|
||4|Load 地址未对齐|
||15|Store/AMO 页故障|
||13|Load 页故障|
||7|Store/AMO 访问故障|
|*最低*|5|Load 访问故障|

当控制转移到 M-Mode 中时，mepc（Machine Exception Program Counter） 寄存器会被自动填入被异步中断打断的指令地址或者导致同步异常的指令地址。

![mepc](https://cn-guoziyang.gitee.io/moonix/assets/img/mepc.png)

当控制转移到 M-Mode 中时，mtval（Machine Trap Value）寄存器会被自动填入 0 或是异常特有的信息，来辅助处理程序处理。

![mtval](https://cn-guoziyang.gitee.io/moonix/assets/img/mtval.png)

当触发硬件断点，或获取指令、Load、Store 时发生地址未对齐、访问故障或是页故障时，mtval 中被写入出错的虚拟地址。对于导致访问或页错误异常的未对齐 Load 或 Store，mtval 将存储导致故障的访问的虚拟地址。对于具有变长指令的系统上的指令获取获取访问异常或是页故障，mtval 存储了导致故障的指令的虚拟地址，而 mepc 指向该条地址的开始。

### 中断相关指令

#### 环境调用

ECALL 指令用于向支持执行环境发出请求。在 U-Mode、S-Mode 和 M-Mode 下执行该指令，会分别生成 environment-call-from-U-mode 异常、environment-call-from-S-mode 异常和 environment-call-from-M-mode 异常。

ECALL 指令会导致被请求的特权模式的 epc 寄存器被设置为 ECALL 指令本身的地址，而不是下一条指令的地址。

#### 从中断处理返回

每个特权模式都各有中断处理返回指令：MRET、SRET 和 URET。除了 mstatus 一节中描述都操作以外，该条指令还会将 pc 寄存器设置为 xepc 的值。

#### 等待中断

WFI 指令会暂停当前硬件线程，直到一个异步中断到来。WFI 指令的执行也可以用来通知硬件平台合适的中断应该优先由该硬件线程处理。在硬件线程暂停时，如果一个被启用的中断发生，中断异常将在 WFI 的下一条指令处发生。

## 内存管理

RICV-V 采用分页机制来对内存进行管理。RISC-V 中，一页是连续的 4K 字节（和大多数平台一致）。RISC-V 中设置了三种分页模式来应对不同场景下的内存管理需求，实现时只需要根据平台特性选择一种即可。以下以 RV64 的 SV39 系统为例。

satp（Supervisor Address Translation and Protection）寄存器，控制了 S-Mode 下的地址翻译和保护。如下：

![satp](https://cn-guoziyang.gitee.io/moonix/assets/img/satp.png)

该寄存器的 PPN 字段（物理页号）保存着根页表的物理页号；ASID 字段（地址空间标识符）是可选的，可以用来降低上下文切换的开销；MODE 字段用来开启分页并选择分页系统。MODE 字段可选编码如下：

|MODE|名称|描述|
|:-:|:-:|:-:|
|0|Bare|不开启分页|
|1|Sv32|基于页的32位虚拟地址系统|
|8|Sv39|基于页的39位虚拟地址系统|
|9|Sv48|基于页的48位虚拟地址系统|

对于 RV32 来说，开启分页的模式只有 Sv32。而 RV64 可以选用 Sv39 和 Sv48。

在 Sv39 中，物理地址有 56 位，而虚拟地址有 64 位。虽然虚拟地址有这么多位，但是其中只有低 39 位有效，第 63 ~ 39 位的值必须等于第 38 位。

在 Sv39 中，物理地址有 56 位，而虚拟地址有 64 位。虽然虚拟地址有这么多位，但是其中只有低 39 位有效，第 63 ~ 39 位的值必须等于第 38 位。

<center><img width=80% alt="SV39 物理地址" src="https://cn-guoziyang.gitee.io/moonix/assets/img/PA.png">

<small>SV39 物理地址</small></center>

<center><img width=80% alt="SV39 虚拟地址" src="https://cn-guoziyang.gitee.io/moonix/assets/img/VA.png">

<small>SV39 虚拟地址</small></center>

将虚拟地址映射为物理地址，这个过程是通过查表进行的。这个表就是页表（Page Table），页表中的每一项即为页表项（Page Table Entry）。

![页表项](https://cn-guoziyang.gitee.io/moonix/assets/img/PTE.png)

<center><small>页表项</small></center>

Sv39 中的页表项长度为 64 位，其中 53 ~ 10 位为一个物理页号，9 ~ 0 位则是各种标志位：

- V 为 Valid，表示这个页表项是否生效。
- X、W、R 分别是 Execute、Writable 和 Readable，表示这个页表项所代表的物理页是否可执行、可写或可读，如果这三个位都置为 0，表示这个页表项并不是指向最终的物理页，而是指向下一级页表。
- U 为 User，表示 U-Mode 下的程序是否可以通过该页表项进行地址映射。如果 U 置为 0，那么 U-Mode 下的程序无法使用该页表项。注意，如果 U 置为 1 时，只有 sstatus 寄存器的 SUM 位也置为 1，S-Mode 下的程序才可以访问该页表项，否则访问会出现错误。
- G 为 Global，表示该页表项在所有地址空间都有效，通常我们不使用这个标记。
- A 为 Accessed，表示自从上次该位被置 0 后，是否有程序访问这个页表项（访问包括读、写或取指）。
- D 为 Dirty，用于在虚拟内存置换时标记脏页。
- RSW 位暂时保留，留给 S-Mode 程序使用。

如果我们想要实现地址翻译，记录下虚拟页到物理页的映射，一个很朴素的想法就是，使用一个数组，数组的下表就是虚拟页号，对应的值就是相应的页表项。

Sv39 的虚拟地址可寻址 2^39 字节，合计 2^27 个虚拟页，如果开一个大数组进行映射，一个页表项占 8 字节，这样一个数组就需要花费 2^30 Byte = 1 GByte 内存来存储！而我们实际可用的物理地址也只有 128 MByte。

Sv39 使用三级页表来解决这个问题。SV39 将 27 位的虚拟页号分成等长的三份，分别用于三级索引，用于索引三级页表。同样的，页表也分为三级，由于每个索引是 9 位，所以一个页表就有 2^9 = 512 个页表项，占用 512 × 8 = 4 KByte 字节，正好可以将一个页表放置在一个物理页中。

地址翻译的过程就很简单了，三级页表的每个页表项中的物理页号描述一个二级页表；二级页表的每个页表项中的物理页号描述一个一级页表；一级页表中的页表项则和我们刚才提到的页表项一样，物理页号描述一个要映射到的物理页帧。过程如下图所示（图源自 MIT 6.s081）。

<center><img width=75% alt="三级页表地址翻译" src="https://cn-guoziyang.gitee.io/moonix/assets/img/sv39_pagetable.jpg"></center>

注意，三级页表和二级页表的每个页表项的 X、W 和 R 位都要置为 0，表示该条页表项指向下一级页表，而非最终的物理页。

在修改 satp 寄存器后，需要通过执行 `SFENCE.VMA` 指令来刷新相关的地址翻译缓存（如 TLB）中的值以防止出现未定义行为。