# RISC-V 硬件机制

本章主要介绍 RISC-V 的相关硬件机制，基于 RV64，SBI 相关机制基于 SBI 标准 v0.2。SBI 实现以 OpenSBI 为例。

## 概览

> RISC-V（发音为“risk-five”）是一个基于精简指令集（RISC）原则的开源指令集架构（ISA），简易解释为开源软件运动相对应的一种“开源硬件”。该项目2010年始于加州大学柏克莱分校，但许多贡献者是该大学以外的志愿者和行业工作者。

RISC-V 是一个典型的 `Load-Store` 类型的指令集架构，这意味着几乎所有的指令的操作数都只能是立即数或者寄存器，而不能是某个内存地址。如果想要修改内存某处的值，只能通过 `Load` 指令将某个内存地址处的值加载到寄存器中，并在修改完成后通过 `Store` 指令将其写入内存。

为了保证架构的可扩展性，RISC-V 采用了模块化设计，包括几个可以互相替换的基本指令集,　以及额外可以选择的扩展指令集。本章及其后的内容将基于 RV64I，并且不会涉及扩展指令集。

## 特权等级

任何时候，RISC-V 硬件线程（*hart*）都运行在某个特权等级下，这些特权级由一个或者多个控制寄存器（*CSR*）编码表示。目前标准定义的三个特权级如下表：

|等级|编码|名称|简写|
|:-:|:-:|:-:|:-:|
|0|00|用户/应用程序（User/Application）|U|
|1|01|监管者（Supervisor）|S|
|2|10|*未定义*||
|3|11|机器（Machine）|M|

特权等级用于在软件堆栈的不同组件之间提供保护，如果试图执行当前特权模式不允许的操作，将引发异常。这些异常通常会导致自陷以进入底层执行环境进行处理。

机器模式拥有最高的特权，并且是 RISC-V 硬件平台唯一强制实现的特权级别。运行在机器模式（M-Mode）中的代码应当是受信任的，因为它对机器实现有低层访问。M-Mode 可以用来管理RISC-V上的安全执行环境。用户模式（U-Mode）和监管者模式（S-Mode）分别用于传统的应用程序和操作系统。

具体的实现可以以降低隔离程度来换取更低的实现成本，三种经典的实现如下表：

|特权等级个数|支持的模式|设计用途|
|:-:|:-:|:-:|
|1|M|简单的嵌入式系统|
|2|M, U|安全的嵌入式系统|
|3|M, S, U|运行 Unix-Like 操作系统|

所有的硬件实现都必须提供 M-Mode，因为这是唯一可以自由访问整个机器的模式。最简单的 RISC-V 实现可能只提供 M-Mode，但这种实现不会对系统提供保护以防止错误或是恶意的应用程序代码。

许多 RISC-V 实现还将至少支持用户模式（U-Mode），以保护系统的其余部分不受应用程序代码的影响。系统实现还可以添加监管者模式（S-Mode），以隔离监管者级操作系统和监管者执行环境（SEE）。

hart 通常在 U-Mode 下运行应用程序代码，直到某些陷阱（例如监管者调用或时钟中断）使得切换到陷阱处理程序（通常特权级更高）。hart 会执行陷阱处理程序，这个陷阱处理程序最终会在 U-Mode 中导致陷阱的指令处或之后恢复执行。提高权限级别的陷阱称为垂直陷阱，而保持在相同权限级别的陷阱称为水平陷阱。垂直陷阱可以在较低特权模式下将控制权返回给水平陷阱处理程序以实现水平陷阱。

## 寄存器组

### 通用寄存器

通用寄存器为 RV64I 指令子集中规定的通用寄存器，虽名为“通用”寄存器，但在 ABI（应用程序二进制接口）中仍然赋予了其中一些寄存器以特殊的含义，以保证编码的统一性。

这些寄存器如下：

|寄存器|ABI 名称|描述|函数调用时保存|
|:-:|:-:|:-:|:-:|
|x0|zero|硬件零|——|
|x1|ra|调用结束后的返回地址|调用者|
|x2|sp|栈顶指针|被调用者|
|x3|gp|全局指针|——|
|x4|tp|线程指针|——|
|x5-7|t0-2|临时寄存器|调用者|
|x8-9|s0-1|被调用者保存寄存器|被调用者|
|x10-17|a0-7|调用参数|调用者保存|
|x18-27|s2-11|被调用者保存寄存器|被调用者|
|x28-31|t3-6|临时寄存器|调用者|

其中 x10（a0）和 x11（a1）在函数调用过程中也用于保存返回值。

#### 函数调用规范

函数调用规范（Calling Convention）是在函数调用发生时，传递参数和返回值的方式的约定。这些约定将由编译器实现。下面仅描述整数调用约定，变量 `XLEN` 指指令集位宽，在 RV64 中该值为 64，RV32 中为 32。

基本的整数调用约定提供了 8 个参数寄存器 a0 ~ a7，前两个寄存器也用于保存返回值。

单个参数寄存器中最多存储 `XLEN` 位宽的数据，如果没有可用的寄存器，那么参数就会被保存在栈上。当将参数存储到寄存器或是栈上时，小于 `XLEN` 位的整数会根据其类型扩展到 32 位，接着再符号扩展到 `XLEN` 位。

单个长度为 `2*XLEN` 参数会存储在一对参数寄存器中，其中低 `XLEN` 位存储在编号较小的寄存器中，高 `XLEN` 位存储在编号较大的寄存器。如果没有可用的寄存器，那么参数就会被保存在栈上，如果恰好只有一个寄存器可用，那么低 `XLEN` 位会保存在寄存器上而高 `XLEN` 位会保存在栈上。

宽度超过 `2*XLEN` 位的参数会以引用的方式传递。

当一个聚合体（如数组或者结构体等）作为一个参数传递时，如果其大小不超过 `XLEN` 位，会直接通过参数寄存器传递，其中字段的布局和在内存中相同。如果没有可用的寄存器，聚合体就会通过栈传递。如果聚合体的总大小不超过 `2*XLEN` 位，该聚合体会通过一对寄存器传递；如果只有一个寄存器可用，那么这个聚合体的前半部分会保存在寄存器中，而后一半会保存在栈上。用于对齐填充的位，以及超过聚合体的末尾且其大小不能被 `XLEN` 整除的位，其行为是未定义的，由编译器实现。

由栈传递的聚合体或是整数会对齐到类型对齐要求或是 `XLEN` 中较大的一个，但是不会超过栈的对齐要求。

位字段以小端序存储。如果某个位字段超出了其整数类型的边界，将填充空余的位到下一个对齐边界。

所有通过引用传递的参数可以被被调用者修改。

在基本的整数调用约定中，可变参数的传递方式和命名参数相同，但是由一个例外情况。以 `2*XLEN` 位对齐且大小最多为 `2*XLEN` 位的可变参数通过一对参数寄存器传递，或者在没有寄存器可用的情况下通过栈传递。当一个可变参数被通过栈传递后，所有后续的参数也都会通过栈传递（例如，最后一个参数寄存器可能由于对齐原因未被使用）。

返回值的传递方式和传递第一个命名参数的方式相同。如果这样的参数是以引用方式传递的，则由调用者为返回值分配内存，并将其地址作为隐式的第一个参数传递。

栈向下增长（向低地址方向），栈顶指针在过程（函数）入口应当对齐到 128 位边界。在函数入口处传递的第一个参数应当位于栈顶指针偏移量为 0 处，后续的参数依次存储在**更高**的地址中。

### 控制寄存器

标准 RISC-V 指令集使用 12 位编码空间来编码控制寄存器（CSR），使得指令集最多支持 4096 个控制寄存器。具体的控制寄存器的作用会在使用时讲解。控制寄存器只有特殊的指令才可以读写，这些指令都是原子指令。

- `csrrw dst, csr, src`<br>
    先将 csr 的值写入 dst，并将 src 的值写入 csr

- `csrr dst, csr`<br>
    将 csr 的值读到 dst

- `csrw csr, src`<br>
    将 src 的值写入 csr

- `csrc(i) csr, rs1`<br>
    将 csr 中指定的位清零，csrc 使用通用寄存器作为 mask，csrci 则使用立即数。

- `csrs(i) csr, rs1`<br>
    将 csr 中指定的位置 1，csrc 使用通用寄存器作为 mask，csrci 则使用立即数。

## 中断机制

微观上，我们使用*异常*来表示当前硬件线程中执行代码发生的特殊情况，而*中断*则表示一个外部的异步事件，这个事件可能引起控制转移，通常与当前执行代码无关。宏观上，我们将其统称为*中断*。

### 全局中断使能

mstatus 寄存器记录了当前硬件线程的状态，由多个状态位组成。mstatus 寄存器在 S-Mode 和 U-Mode 中分别以 sstatus 和 ustatus 的名称被访问，事实上它们都是同一个寄存器的不同视图，高权限级的视图可以访问更多的状态位，低权限级低视图只能访问受限的位。

![mstatus](https://cn-guoziyang.gitee.io/moonix/assets/img/mstatus.png)

mstatus 寄存器中，MIE、SIE 和 UIE，分别是不同权限等级的全局中断使能位。当硬件线程以 x-Mode 运行时，xIE=1 时全局启用中断，xIE=0 时全局禁用中断，全局启用中断意味着，在该模式下运行的线程会被中断打断，并进入到中断处理流程中。

如果 xIE=1，低特权级 w 的中断会被全局禁用，无论是否设置 wIE 位。类似，高特权级 y 的中断会被全局启用，无论是否设置 yIE 位。高权限级代码可以使用单独的中断启用位来禁用选定的高权限模式中断，然后将控制权让与低权限模式。

为了支持嵌套中断处理，每个特权模式 x 都有两套中断启用位和特权级。xPIE 位存储了中断处理发生前的中断使能位的值，xPP 存储了上一个特权模式。由于 xPP 字段只能存储高于 x 的特权模式，所以 MPP 是两位宽，SPP 是一位宽，而 UPP 隐式为 0 。当中断处理从特权模式 y 进入特权模式 x 时，xPIE 被设置为 xIE 的值，xIE 被设置为 0，xPP 被设置为 y。

指令 `MRET`、`SRET` 和 `URET` 分别用于从 M-Mode、S-Mode 和 U-Mode 的中断处理中返回。当执行 `xRET` 指令时，假设 xPP 寄存器中的值为 y，那么 xIE 会被设置为 xPIE 的值，特权模式会变为 y，xPIE 会被设置为 1，xPP 会被设置为 U（如果系统不支持 U-Mode 则会设置为 M）。

xPP 字段是 **WARL**（Write any values, read legal values）字段，只能保存低于或等于 x 的特权模式，如果系统没有实现 x 模式，xPP 必须被硬连接到 0。

### 具体类型中断使能

具体类型的中断使能设置涉及了一对寄存器：mip 和 mie，这对寄存器在 S-Mode 和 U-Mode 下同样也有一对受限的视图，sip/sie 和 uip/uie。mip 中存储了未决中断（pending interrupts）的相关信息，而 mie 中存储了具体类型的中断使能信息。

![mip](https://cn-guoziyang.gitee.io/moonix/assets/img/mip.png)

![mie](https://cn-guoziyang.gitee.io/moonix/assets/img/mie.png)

MTIP、STIP、UTIP 位分别对应于 M-Mode、S-Mode 和 U-Mode 时钟中断的时钟中断位决位。MTIP 位是只读的，只能通过写入内存映射的 M-Mode 时钟比较寄存器来清除。UTIP 和 STIP 位可以被 M-Mode 代码修改，用来设置低权限级的时钟中断。

对于不同模式的时钟中断，mie 中分别有一个时钟中断使能位：MTIE、STIE 和 UTIE。

软件中断和外部中断与时钟中断类似。

只有 mip 和 mie 中的位 i（i 指时钟、软件或外部中断）被设置为 1，且全局启用了中断，才能启用 i 中断。默认情况下，如果硬件线程的当前特权模式低于 M 模式，或者当前特权模式是 M 且 mstatus 寄存器中的 MIE 位置为 1，M-Mode 的中断就是全局启用的。

不同权限模式的多个并发中断按照权限模式递减的顺序进行处理，同一个特权模式下的多个并发中断按照以下优先级递减顺序处理：MEI、MSI、MTI、SEI、SSI、STI、UEI、USI、UTI。同步异常的优先级低于所有异步中断。

### 中断处理程序

此处中断处理程序以 M-Mode 为例，涉及的寄存器只需要更换寄存器名前缀即可推广到不同的特权模式。

当 M-Mode 异常或是中断发生时，如果开始了对应类别的中断，并且全局使能中断，那么当前硬件线程的执行流程会被打断，控制转移到中断处理程序。mtvec 寄存器配置控制转移过程，该寄存器由一个向量基地址（BASE）和向量模式（MODE）组成。

![mtvec](https://cn-guoziyang.gitee.io/moonix/assets/img/mtvec.png)

BASE 字段的值必须至少对齐 4 字节边界，MODE 的设置可能对 BASE 字段的对齐模式增加更严格的对齐限制。

|MODE 值|名称|描述|
|:-:|:-:|:-:|
|0|Direct|所有的中断发生时，都会跳转到 BASE 处|
|1|Vectored|异步中断发生时，pc 会被设置为 `BASE+4×cause`|
|>=2|——|*保留*|

由上表，当 MODE 为 Direct 时，所有进入 M-Mode 的中断都会导致 pc 被设置为 BASE 字段中的地址。当 MODE 为 Vectored 时，所有进入 M-Mode 的同步异常都会导致 pc 被设置为 BASE 字段中的地址，而异步中断则会导致 pc 被设置为 BASE 字段中的地址加上中断原因编码的四倍。例如，当一个 M-Mode 的时钟中断发生时，pc 会被设置为 `BASE+0x1c`。中断原因编码会在讲述 scause 寄存器时讲解。

### 中断信息



## 内存管理

## 并发