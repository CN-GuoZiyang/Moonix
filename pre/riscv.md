# RISC-V 硬件机制

本章主要介绍 RISC-V 的相关硬件机制，基于 RV64，SBI 相关机制基于 SBI 标准 v0.2。

## 概览

> RISC-V（发音为“risk-five”）是一个基于精简指令集（RISC）原则的开源指令集架构（ISA），简易解释为开源软件运动相对应的一种“开源硬件”。该项目2010年始于加州大学柏克莱分校，但许多贡献者是该大学以外的志愿者和行业工作者。

RISC-V 是一个典型的 `Load-Store` 类型的指令集架构，这意味着几乎所有的指令的操作数都只能是立即数或者寄存器，而不能是某个内存地址。如果想要修改内存某处的值，只能通过 `Load` 指令将某个内存地址处的值加载到寄存器中，并在修改完成后通过 `Store` 指令将其写入内存。

为了保证架构的可扩展性，RISC-V 采用了模块化设计，包括几个可以互相替换的基本指令集,　以及额外可以选择的扩展指令集。本章及其后的内容将基于 RV64I，并且不会涉及扩展指令集。

## 特权等级

任何时候，RISC-V 硬件线程（*hart*）都运行在某个特权等级下，这些特权级由一个或者多个控制寄存器（*CSR*）编码表示。目前标准定义的三个特权级如下表：

|等级|编码|名称|简写|
|:-:|:-:|:-:|:-:|
|0|00|用户/应用程序（User/Application）|U|
|1|01|监管者（Supervisor）|S|
|2|10|*未定义*||
|3|11|机器（Machine）|M|

特权等级用于在软件堆栈的不同组件之间提供保护，如果试图执行当前特权模式不允许的操作，将引发异常。这些异常通常会导致自陷以进入底层执行环境进行处理。

机器模式拥有最高的特权，并且是 RISC-V 硬件平台唯一强制实现的特权级别。运行在机器模式（M-Mode）中的代码应当是受信任的，因为它对机器实现有低层访问。M-Mode 可以用来管理RISC-V上的安全执行环境。用户模式（U-Mode）和监管者模式（S-Mode）分别用于传统的应用程序和操作系统。

具体的实现可以以降低隔离程度来换取更低的实现成本，三种经典的实现如下表：

|特权等级个数|支持的模式|设计用途|
|:-:|:-:|:-:|
|1|M|简单的嵌入式系统|
|2|M, U|安全的嵌入式系统|
|3|M, S, U|运行 Unix-Like 操作系统|

所有的硬件实现都必须提供 M-Mode，因为这是唯一可以自由访问整个机器的模式。最简单的 RISC-V 实现可能只提供 M-Mode，但这种实现不会对系统提供保护以防止错误或是恶意的应用程序代码。

许多 RISC-V 实现还将至少支持用户模式（U-Mode），以保护系统的其余部分不受应用程序代码的影响。系统实现还可以添加监管者模式（S-Mode），以隔离监管者级操作系统和监管者执行环境（SEE）。

hart 通常在 U-Mode 下运行应用程序代码，直到某些陷阱（例如监管者调用或时钟中断）使得切换到陷阱处理程序（通常特权级更高）。hart 会执行陷阱处理程序，这个陷阱处理程序最终会在 U-Mode 中导致陷阱的指令处或之后恢复执行。提高权限级别的陷阱称为垂直陷阱，而保持在相同权限级别的陷阱称为水平陷阱。垂直陷阱可以在较低特权模式下将控制权返回给水平陷阱处理程序以实现水平陷阱。

## 寄存器组

### 通用寄存器

通用寄存器为 RV64I 指令子集中规定的通用寄存器，虽名为“通用”寄存器，但在 ABI（应用程序二进制接口）中仍然赋予了其中一些寄存器以特殊的含义，以保证编码的统一性。

这些寄存器如下：

|寄存器|ABI 名称|描述|函数调用时保存|
|:-:|:-:|:-:|:-:|
|x0|zero|硬件零|——|
|x1|ra|调用结束后的返回地址|调用者|
|x2|sp|栈顶指针|被调用者|
|x3|gp|全局指针|——|
|x4|tp|线程指针|——|
|x5-7|t0-2|临时寄存器|调用者|
|x8-9|s0-1|被调用者保存寄存器|被调用者|
|x10-17|a0-7|调用参数|调用者保存|
|x18-27|s2-11|被调用者保存寄存器|被调用者|
|x28-31|t3-6|临时寄存器|调用者|

其中 x10（a0）和 x11（a1）在函数调用过程中也用于保存返回值。

#### 函数调用规范

函数调用规范（Calling Convention）是在函数调用发生时，传递参数和返回值的方式的约定。这些约定将由编译器实现。下面仅描述整数调用约定，变量 `XLEN` 指指令集位宽，在 RV64 中该值为 64，RV32 中为 32。

基本的整数调用约定提供了 8 个参数寄存器 a0 ~ a7，前两个寄存器也用于保存返回值。

单个参数寄存器中最多存储 `XLEN` 位宽的数据，如果没有可用的寄存器，那么参数就会被保存在栈上。当将参数存储到寄存器或是栈上时，小于 `XLEN` 位的整数会根据其类型扩展到 32 位，接着再符号扩展到 `XLEN` 位。

单个长度为 `2*XLEN` 参数会存储在一对参数寄存器中，其中低 `XLEN` 位存储在编号较小的寄存器中，高 `XLEN` 位存储在编号较大的寄存器。如果没有可用的寄存器，那么参数就会被保存在栈上，如果恰好只有一个寄存器可用，那么低 `XLEN` 位会保存在寄存器上而高 `XLEN` 位会保存在栈上。

宽度超过 `2*XLEN` 位的参数会以引用的方式传递。

当一个聚合体（如数组或者结构体等）作为一个参数传递时，如果其大小不超过 `XLEN` 位，会直接通过参数寄存器传递，其中字段的布局和在内存中相同。如果没有可用的寄存器，聚合体就会通过栈传递。如果聚合体的总大小不超过 `2*XLEN` 位，该聚合体会通过一对寄存器传递；如果只有一个寄存器可用，那么这个聚合体的前半部分会保存在寄存器中，而后一半会保存在栈上。用于对齐填充的位，以及超过聚合体的末尾且其大小不能被 `XLEN` 整除的位，其行为是未定义的，由编译器实现。

由栈传递的聚合体或是整数会对齐到类型对齐要求或是 `XLEN` 中较大的一个，但是不会超过栈的对齐要求。

位字段以小端序存储。如果某个位字段超出了其整数类型的边界，将填充空余的位到下一个对齐边界。

所有通过引用传递的参数可以被被调用者修改。

在基本的整数调用约定中，可变参数的传递方式和命名参数相同，但是由一个例外情况。以 `2*XLEN` 位对齐且大小最多为 `2*XLEN` 位的可变参数通过一对参数寄存器传递，或者在没有寄存器可用的情况下通过栈传递。当一个可变参数被通过栈传递后，所有后续的参数也都会通过栈传递（例如，最后一个参数寄存器可能由于对齐原因未被使用）。

返回值的传递方式和传递第一个命名参数的方式相同。如果这样的参数是以引用方式传递的，则由调用者为返回值分配内存，并将其地址作为隐式的第一个参数传递。

栈向下增长（向低地址方向），栈顶指针在过程（函数）入口应当对齐到 128 位边界。在函数入口处传递的第一个参数应当位于栈顶指针偏移量为 0 处，后续的参数依次存储在**更高**的地址中。

### 控制寄存器

标准 RISC-V 指令集使用 12 位编码空间来编码控制寄存器（CSR），使得指令集最多支持 4096 个控制寄存器。具体的控制寄存器的作用会在使用时讲解。控制寄存器只有特殊的指令才可以读写，这些指令都是原子指令。

- `csrrw dst, csr, src`<br>
    先将 csr 的值写入 dst，并将 src 的值写入 csr

- `csrr dst, csr`<br>
    将 csr 的值读到 dst

- `csrw csr, src`<br>
    将 src 的值写入 csr

## 中断机制

## 定时器（时钟）

## 内存管理

## 并发