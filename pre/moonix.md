# Moonix 体系结构

本章将简明描述 Moonix 操作系统的体系结构和主要的构成模块，旨在让读者对 Moonix 操作系统有一个整体的把握。

目前，整个 Moonix 操作系统由两个部分组成：监管者模式部分和用户模式部分。监管者模式部分即操作系统内核，用于对硬件资源进行抽象和调度访问，向下沟通位于机器模式的 SBI，向上应答用户模式的服务请求。用户模式部分，即操作系统服务，目前主要实现的是内核编程接口，用户编写的程序不会直接向监管者模式请求服务，而是通过调用内核编程接口函数，由这些函数代为请求。

## 体系结构

Moonix 整体采用了宏内核模式，宏内核的优点是执行速度快，缺点则是层次结构性不强。尽管如此，我们还是可以将其大概划分为以下四个模块：中断处理模块、内存管理模块、进程调度模块和文件系统模块。

中断处理模块用于控制操作系统对内外部中断的响应。操作系统通过响应时钟中断，来定时检查进程的运行状态，可以说中断处理是进程调度的基础。内存管理模块主要通过虚拟内存管理的方式，保证各个进程能够安全共享物理内存，互不干扰。同时，由于各个进程都运行在独立的虚拟内存空间，使得各个程序实现时不必考虑实际的物理内存状态，降低了程序实现的难度。进程调度模块用来控制进程对 CPU 的使用，通过 Round-Robin 算法，来保证各个进程能够公平地使用 CPU 资源，同时内核也能够及时地响应外部中断。文件系统模块屏蔽了不同文件系统的细节，提供了一个通用的文件接口。

从宏内核模式结构模型（分层思想）出发，我们可以将 Moonix 的层次结构大致描述为如下框图：



// 此处应有框图



## 中断处理模块

对于 Moonix 来说，中断根据中断源可以大致分为两类：内部中断和外部中断，内部中断又可以分为异常和陷阱。

**异常（Exception）**：在执行一条指令时发生错误，这个错误是由这个指令本身引起的，这时就需要进入中断来处理错误。有些错误是可以恢复的，例如缺页异常，中断处理程序将需要的页面调入内存后再次执行导致异常的指令即可。而有些异常不可恢复，如除零异常，遇到这种异常中断处理程序会直接终止当前程序。

**陷阱（Trap）**：陷阱是由程序主动引发的中断，程序通过陷阱机制可以主动向操作系统请求服务。常见的有通过 `ecall` 指令进行系统调用，或者通过 `ebreak` 指令进入断点。

**外部中断（Interrupt）**：狭义的中断专指外部中断，这类中断和当前运行的程序无关，是由外部设备引发的。例如时钟中断或外部设备发送数据等。

中断处理模块最主要的用途，就是通过处理时钟中断，来暂时打断当前进程以进行进程调度，同时通过处理陷阱，来处理来自 U-Mode 下应用程序发起的环境调用。

RISC-V 已经规定了中断发生时的 `scause` 寄存器被设置的值，操作系统可以根据这个寄存器中的值来判断中断类型。Moonix 采取 Direct 模式处理中断，这意味着无论发生什么中断，控制都会跳转到同一个位置。

## 内存管理模块

Moonix 操作系统目前只能运行在 QEMU 模拟的 virt 计算机上，并且以 OpenSBI 作为 SBI。因此，Moonix 可管理的内存受制于 virt 和 OpenSBI。

在 virt 中，将各种设备内存映射到了物理地址空间 0x0 ～ 0x80000000 处。0x80000000 以上的 128 MB 内存则是可供操作系统使用的物理内存空间。这其中，OpenSBI 会占据 0x80000000 ～ 0x80200000 这段内存，而操作系统的代码段和数据段等。kernel/kernel.ld 链接脚本定义了一个全局符号 `kernel_end`，标识了内核的结束位置。从 kernel_end 到 0x88000000 这段物理内存，就是我们可以任意使用的物理内存了。

Moonix 目前有两种内存分配方式，一种是在上面提到的空闲内存上按页（4 KB）进行分配，一种是在内核堆（定义在 .bss 段上 8 MB 大小的字节数组）上进行动态内存分配。

由于计算机的物理内存是有限的（譬如 virt 只有 128 MB），CPU 通常都会提供一些内存管理机制来对物理内存进行有效管理。在 RISC-V 中。提供了分页管理系统来对内存进行管理和虚拟化。

内存分页的原理是将整个内存区域划分为 4 KB 为一页的内存页。程序使用内存时，以一页为单位进行分配。Moonix 采用 RISC-V 提供的 Sv39 分页系统，虚拟地址有效位是 39 位，这意味着虚拟内存空间共 2^39 字节（512 GB），远远大于可用的物理内存空间。

RISC-V 借助页表进行地址翻译，不同的进程可以拥有不同的页表。Sv39 采用了三级页表，每当进程请求一个虚拟内存地址的数据时，都会由 CPU 进行地址变换，首先将其转换为物理内存地址，再交由内存进行实际的数据读取。地址翻译的过程如下所示：

![Sv39 地址翻译](https://cn-guoziyang.gitee.io/moonix/assets/img/sv39_pagetable.jpg)

Moonix 中整体的虚拟地址空间到物理地址空间的映射如下：

// 此处应有映射图

关于内存管理更详细的内容，请参见第三章与第四章。

## 进程调度模块

程序是存储设备中静态的可执行文件，而进程，是一个正在运行状态的程序实例，拥有自己的内存空间和运行时数据。在 Moonix 实现中采用了一个很简单的进程模型，一个进程中只包含一个线程。这样，剥离出进程资源分配的属性，我们要讨论进程的执行调度，其实就是在讨论线程的调度。Moonix 内核中，除去用于调度的 idle 线程外，最多可以支持 64 个线程同时存在。内核通过线程 id（pid）来标识每个线程。每个进程除去一个线程外，还包含了一个页表和一个打开的文件描述符表。

Moonix 使用 Round-Robin 算法，将 CPU 运行时间划分为时间片，每个线程一次可以在一个时间片内运行。内核维护一个线程队列，当队首线程的时间片用完后，调度线程会将其移动到队尾，并让下一个线程开始占用 CPU 运行。

Moonix 通过线程池，来对线程进行直接管理。线程结构本身只用于保存其相关数据的信息，如上下文地址、栈底地址等，而例如状态等信息，则由线程池进行维护。线程池的本质是一个数组，每一个元素都是一个 ThreadInfo 结构体。该结构体中除去一个状态信息 status 字段外，就包含的一个 Thread 结构体。定义如下：

```c
typedef struct {
    usize contextAddr;  /* 线程上下文存储的地址 */
    usize kstack;       /* 线程栈底地址 */
    Process process;    /* 所属进程 */
    int wait;           /* 等待该线程退出的线程的 Tid */
} Thread;
```

在 Moonix 中，进程看上去更像是线程的附属，维护一个线程的相关资源。

```c
typedef struct {
    usize satp;         /* 页表寄存器 */
    File oFile[16];     /* 文件描述符 */
    uint8 fdOccupied[16];   /* 文件描述符是否被占用 */
} Process;
```

在一个线程运行时，CPU 中寄存器的值以及线程栈上的值，成为这个线程的上下文。在线程切换时，需要将上一个线程的上下文保存起来，以便在未来再次切换到这个线程时，能够继续之前的状态运行下去。在线程创建时，就会在线程栈上分配一个空间用于存放线程上下文，在未来线程切换时，上下文都会保存在线程栈上的同一位置。

在 Moonix 中，线程 Thread 结构体本身并不保存其状态，状态的维护由线程池来完成。Moonix 简单地将线程的状态划分为四种：

```c
/* 线程状态 */
typedef enum {
    Ready,
    Running,
    Sleeping,
    Exited
} Status;
```



// 此处应有线程状态转换图



- **就绪状态（Ready）**：线程处于就绪队列中，等待被 CPU 调度执行
- **运行状态（Running）**：线程此时正占有 CPU 运行
- **睡眠状态（Sleeping）**：线程等待某个条件满足，此时线程不会被调度执行，直到条件满足后才会被加入就绪队列
- **退出状态（Exited）**：线程已经完成了任务执行，但是还没有回收资源

## 文件系统模块

Moonix 中采用的文件系统，是 SimpleFileSystem 的一个魔改版本。名称仍然延用 SimpleFS。该文件系统结构如下：

![sfs](https://cn-guoziyang.gitee.io/moonix/assets/img/sfs.png)

SimpleFS 将磁盘分成了多个大小为 4096 字节的磁盘块。

一个 SimpleFS 文件系统的第一块恒为超级块（SuperBlock），它记录了整个文件系统的基本信息，例如总磁盘块数、未使用的磁盘块数、Freemap 块个数等。

紧随其后的是若干个 Freemap 块，它记录了整个文件系统中磁盘块的占用情况。Freemap 块使用一个 bit 表示一个块，0 为未被占用，1 为已被占用。通过 Freemap 块我们就可以快速找到空闲可用的磁盘块。

Freemap 块后面是表示根文件系统的 Inode 块。SimpleFS 也是以树状结构组织文件的，Root 即为 “/” 文件夹。

Root Inode 后就是其他文件的 Inode 或者数据块了，这些块不会做特殊的排序等，查找文件需要从根目录开始查找。

目前的文件系统实现是在链接时直接将文件系统镜像链接到 .data 段，在运行时文件系统就会和内核一起直接被加载进内存。