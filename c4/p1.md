# 4.1 Sv39

----

# 从虚拟内存到物理内存

从最开始我们就知道，我们编写的操作系统是一个 64 位的操作系统，地址的长度是 64 位。那么我们可以访问的内存空间，大小就是 2^64 Byte = 2^24 TB。

当然现实中我们不可能有这么大的一块内存（或许不久的将来会有），所以我们将其称为**虚拟内存**。同样我们也知道，所有的数据事实上都是存储在物理内存上的，CPU 访问这些数据只能通过**物理内存**。

所以，当程序按照假想的虚拟地址运行在虚拟地址空间上时，CPU 就必须有相应的机制，来将虚拟地址转换成物理地址，以真正地去内存上请求所需要的代码和数据。

这种“地址实时翻译”的想法有助于我们实现一些有趣的特性，譬如，两个不同的进程可以访问一个相同的虚拟地址，但是它们各有一套不同的地址翻译机制，最终访问到的是两个不同的物理地址的数据。这种特性有助于我们在实现用户进程的时候，不必考虑物理内存空间的实际布局，只需要自顾自地把它放在一个固定的虚拟地址，操作系统就会将不同的进程映射到不同的物理地址上。再譬如，当我们不希望物理地址空间中的某些部分被某个进程访问时，我们可以不映射这块内存到该进程的虚拟地址空间。

硬件已经实现了诸多机制用于快速地进行这样的映射，操作系统所需要做的，就是指导硬件，设置一些机制，随后，硬件就会自动地按照这个机制来转换虚拟地址了。在 RISC-V 中，这个映射的具体实现，就是**页表**。

# SV39

RV64 中，页表的实现主要有两种：Sv39 和 Sv48。这里我们采用 Sv39 作为我们的页表实现。

在 Sv39 中，物理地址有 56 位，而虚拟地址有 64 位。虽然虚拟地址有这么多位，但是其中只有低 39 位有效，第 63 ~ 39 位的值必须等于第 38 位。

<center><img width=80% alt="SV39 物理地址" src="https://cn-guoziyang.gitee.io/moonix/assets/img/PA.png">

<small>SV39 物理地址</small></center>

<center><img width=80% alt="SV39 虚拟地址" src="https://cn-guoziyang.gitee.io/moonix/assets/img/VA.png">

<small>SV39 虚拟地址</small></center>

Sv39 也是基于页的。我们曾在上一章中提到了按页分配，分配的是物理页，每一页大小 4K 字节，物理页号有 48 位。同样的，我们定义虚拟页，虚拟页的大小和物理页相同，也是 4K 字节，虚拟页号有 27 位。基于这种方式，我们恰好可以完整地将一个虚拟页映射到一个物理页上。

# 页表项

将虚拟地址映射为物理地址，这个过程是通过查表进行的。这个表就是**页表（Page Table）**，页表中的每一项即为**页表项（Page Table Entry）**。

![页表项](https://cn-guoziyang.gitee.io/moonix/assets/img/PTE.png)

<center><small>页表项</small></center>

Sv39 中的页表项长度为 64 位，其中 53 ~ 10 位为一个物理页号，9 ~ 0 位则是各种标志位：

- V 为 Valid，表示这个页表项是否生效。
- X、W、R 分别是 Execute、Writable 和 Readable，表示这个页表项所代表的物理页是否可执行、可写或可读，如果这三个位都置为 0，表示这个页表项并不是指向最终的物理页，而是指向下一级页表。
- U 为 User，表示 U-Mode 下的程序是否可以通过该页表项进行地址映射。如果 U 置为 0，那么 U-Mode 下的程序无法使用该页表项。注意，如果 U 置为 1 时，只有 sstatus 寄存器的 SUM 位也置为 1，S-Mode 下的程序才可以访问该页表项，否则访问会出现错误。
- G 为 Global，表示该页表项在所有地址空间都有效，通常我们不使用这个标记。
- A 为 Accessed，表示自从上次该位被置 0 后，是否有程序访问这个页表项（访问包括读、写或取指）。
- D 为 Dirty，用于在虚拟内存置换时标记脏页。
- RSW 位暂时保留，留给 S-Mode 程序使用。

# 多级页表

如果我们想要实现地址翻译，记录下虚拟页到物理页的映射，一个很朴素的想法就是，使用一个数组，数组的下表就是虚拟页号，对应的值就是相应的页表项。

Sv39 的虚拟地址可寻址 2^39 字节，合计 2^27 个虚拟页，如果开一个大数组进行映射，一个页表项占 8 字节，这样一个数组就需要花费 2^30 Byte = 1 GByte 内存来存储！而我们实际可用的物理地址也只有 128 MByte。

Sv39 使用三级页表来解决这个问题。SV39 将 27 位的虚拟页号分成等长的三份，分别用于三级索引，用于索引三级页表。同样的，页表也分为三级，由于每个索引是 9 位，所以一个页表就有 2^9 = 512 个页表项，占用 512 × 8 = 4 KByte 字节，正好可以将一个页表放置在一个物理页中。

地址翻译的过程就很简单了，三级页表的每个页表项中的物理页号描述一个二级页表；二级页表的每个页表项中的物理页号描述一个一级页表；一级页表中的页表项则和我们刚才提到的页表项一样，物理页号描述一个要映射到的物理页帧。过程如下图所示（图源自 MIT 6.s081）。

<center><img width=75% alt="三级页表地址翻译" src="https://cn-guoziyang.gitee.io/moonix/assets/img/sv39_pagetable.jpg"></center>

注意，三级页表和二级页表的每个页表项的 X、W 和 R 位都要置为 0，表示该条页表项指向下一级页表，而非最终的物理页。

# satp

三级页表的地址翻译过程很清晰，只要找到三级页表的位置，就能依次逐级找到最终的物理页。那么，CPU 如何得知三级页表的基地址呢？答案就是 satp 寄存器。

satp ，即 Supervisor Address Translation and Protection，用于保存根页表（Sv39 中为三级页表）的基地址，以及采用的地址翻译模式。结构如下：

<center><img width=80% alt="satp 寄存器" src="https://cn-guoziyang.gitee.io/moonix/assets/img/satp.png"></center>

- MODE 控制 CPU 采用哪种页表实现，当 MODE = 8 时表示采用 SV39 实现
- ASID 是地址空间标识符，在实现进程时需要使用该字段
- PPN 存储三级页表的地址所在的物理页号

有了该寄存器，操作系统就可为不同的程序建立不同的地址空间，并通过设置 satp 来设置页表，进而在不同的地址空间中切换。