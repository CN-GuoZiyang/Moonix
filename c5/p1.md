# 5.1 线程定义

----

# 进程和线程

磁盘中存储的静态代码，经过编译、链接后形成的可执行文件，称为程序。进程就是被操作系统分配了资源并正在运行中的程序。进程这个词强调动态性，**占用资源**且**正在运行**。操作系统将静态的程序加载到内存中，程序定义的各个段都被正确地映射出来，并且还占用一定的资源，如页表和文件描述符，同时，这个进程在适当的时候还可以占有 CPU，被 CPU 取指执行。

线程是进程中正在运行的程序流，更关注其“正在运行”的特性。如果剥离线程，进程只需要负责维护操作系统所分配的资源。一个进程可以有多个线程，也可以只有一个线程。单个进程内有多个线程的情况下，线程会共享进程被分配到的资源。

这样剥离开来，进程就成了**操作系统分配资源的最小单位**，管理页表、文件等资源。而线程则更专注于执行，是 **CPU 调度的最小单位**。

# 线程的状态表示

线程负责执行，我们可以通过**线程上下文**来描述一个线程当前的执行状态。一个线程的执行状态包括一下两个组成：

- CPU 中各个寄存器的值。

    我们关心一个线程运行到了哪里，关心程序运行过程中产生的中间结果，这些都记录在 pc 寄存器即其他各种寄存器中。

- 线程栈

    线程在进行函数调用的时候，需要将各种信息压栈，并借助寄存器和栈进行参数和返回值的传递。同时，函数在运行时的各种局部变量都是在栈上分配的。

在并发的情况下，一个线程不会总是占有 CPU，可能会在运行未完成时被 CPU 切换出去，并在某个时刻切换回来。

其他线程不会修改当前线程的栈（但是有这个能力），我们没有必要保存栈上内容。这样的话，我们只需要保存 CPU 中寄存器的值就好了。这就有点像中断发生时保存上下文的场景了，不过，由于采用函数调用的方式来切换线程，我们不用保存所有的寄存器。事实上，我们只需要保存以下内容：

- ra 寄存器，用于保存返回地址
- satp 寄存器，保存页表信息，本章的线程都可以说是同属于内核进程的，共用一个页表
- s0 ~ s11，函数调用中被调用者保存的寄存器

具体的通过函数调用切换线程的方法，会在第二节线程切换部分说明。

# 线程实现

基于以上内容，我们来定义线程上下文。

```c
// kernel/context.h

// 线程运行上下文
typedef struct {
    usize ra;
    usize satp;
    usize s[12];
    InterruptContext ic;
} ThreadContext;
```

除去我们说的三部分内容以外，还包含了一个中断上下文，严格来说这不属于线程运行上下文的一部分，我们只是会借助中断返回机制来初始化线程，这部分仅会在线程初始化时被保存在栈上，后续并不会被保存。

之后，我们就可以定义线程了：

```c
// kernel/thread.h

// 线程结构定义
typedef struct {
    // 线程上下文存储的地址
    usize contextAddr;
    // 线程栈底地址
    usize kstack;
} Thread;
```

线程上下文只需要保存其地址，只有在切换线程时才需要关心线程上下文保存的位置。而保存栈底地址主要是为了在线程结束后能够回收这片空间，栈空间通过动态内存分配，后面会提到。