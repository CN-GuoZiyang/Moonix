- [x] 完成项目整体概述文档
- [ ] 修整已经写完的文档部分，绘制一些辅助图片
- [ ] 统一文件读写与文件夹相关的系统调用
- [ ] 尝试加载可执行文件时重定位全局变量
- [x] 修正第一章节的 bug


# 20210224 by guojun

- [x] 用Markdown整理一个全局目录，这样大体上干什么，逻辑更清楚，如下所示，弄完的打对勾就行，要完成的就放在那，尽量先把目录补充完整
- [x] SBI接口简介，从如何启动写起，是什么？为什么？如何用？
- [x] 增加一些调试的内容，如GDB简介，网上很多，可以举一个简单例子，进行调试举例，就像你写公众号文章一样
- [ ] **[RISC-V Assembly Interpreter](https://www.cs.cornell.edu/courses/cs3410/2019sp/riscv/interpreter/#)**
这个网址可视化的很好，可以手写汇编语句，实时编译，有点在线bochs的感觉
- [ ] RISC-V 手册，包云刚版，第2，3，9，10章，看看哪些，是你编程时，必须的知识，可加进来一些
- [ ] 图片和表格后期我会用Latex统一处理，你现在就是把内容都先填上
  - [ ] 图片出现的地方，你可以直接先截图放上，然后把图片的出处标上，如xx手册，图 4-13等
  - [ ] 表格跟图片一样，你可以直接先截图放上，然后把表格的出处标上，如xx手册，Table 2-11等
- [x] 你这里实现已经有几章了，把你整体的设计，画一个总的框架图，先用visio画就行，主要体现出来各个章节的逻辑关系，如启动、进程管理，内存管理，文件管理，I\O等，然后每一部分大概做了什么，自己设计一下，目的就是让读者快速了解整个框架涵盖的内容


# 20210311 by guojun

# 前置知识
写的可以
- [ ] gdb
  gdb 如何查看这些特殊的寄存器，stvec sstatus，可以在后面的第一二章增加一小节如何用GDB调试，并查看这些特殊寄存器，来辅助理解一些概念
- [x] 体系结构里面把寄存器介绍，中断机制等介绍一下，有个总体印象（寄存器等内容在硬件机制和汇编中，中断机制等已在体系结构中更新）

# 第一章
- [ ] 1.1 内核入口点
  - [ ] entry.S 上来的写法有点突兀，没有基础的乍一看就蒙了，之前可以简单介绍一下汇编一般是如何书写和布局的
  - [x] 这里能不能画一个entry.S内存分布图，主要是初学者不会知道你现在的汇编程序是怎么占用空间的
  - [x] risc-v初始启动时，内存大致是怎么分配的，0x80200000大致在什么位置，同时引出个问题，怎么把汇编代码编译完的结果放到指定的0x80200000，埋下一个伏笔
- [x] 1.3 设置交叉编译工具链
  - [x] gcc 编译选项那里6行CFLAGS的注释加一下，这些选项的作用是什么 
- [x] 1.4 封装 SBI 接口
  - [x] ecall scall 写法统一，我看有的文档都是大写的
  - [x] 实现 printf，以下的 printf() 实现来自于 xv6，xv6给出引用的超链接

# 第二章

- [ ] 2.2 配置中断处理程序
  - [x] kernel/interrupt.c 代码缩进对齐
  - [ ] Interrupt cause: 0x0000000000000003 查手册62页 表4.2 2–3 Reserved for future standard use，可以扩展写一点，这样读者会有更好的体验感
  - [ ] epc: 0x0000000080200522 如果这里大概能让读者看到内存的分布状况更好，大致能理解522是怎么来的，因为现在代码还不多，有个打印字符的程序，和中断程序
- [ ] 2.2 函数对齐
  - [ ] 我们在上一节提到 stvec 时说过，RISC-V 要求中断处理程序的入口需要四字节对齐。因为 stvec 寄存器的低两位被 MODE 占据了。如果中断处理程序的入口没有对齐，如 0x80200522，在存入 stvec 时低两位就会被舍去，中断处理是就会跳转到 0x80200520 处去！这个地址甚至可能不是一个完整指令的起始地址，CPU 无法解析残缺的指令，就会陷入错误，导致重启。这里的重启原因，可以深入跟踪一下，我上课时，给你们讲过，如何重启的过程，里面是不停地跳转到非法代码，然后响应异常中断，你这里为什么会有3行***** Init Interrupt *****，而却没有Interrupt cause: epc Interrupt handled!等字样，解释的没有那么透彻，可以补充一下
- [x] 2.3 中断上下文
  - [x] 这里如果特权级发生变化，栈的处理是怎么进行的，应该把思想介绍一下，像x86，特权级变化伴随栈切换，两个栈顶什么时候设置的，切换的时候，谁的值被赋给栈顶寄存器了（目前中断前后不会切换特权级，在用户进程那一章时再多开一节关于中断前后特权级切换的内容）
  - [x] 这里最好能画一个草图，就是把中断前后，如何保存相应通用寄存器，状态寄存器，控制寄存器等画出来，示意图就好，还有跟栈的关系，这些就是最起码的操作，但是硬件提供的机制，x86与riscv就是不同的处理方式，懂得人看你现在写的大致能懂，如果初学者看到这就会有点懵。此外，这里面关于栈的寄存器有哪些？应该在哪个位置介绍一下
- [x] 2.4 设置时钟中断处理流程
  - [x] case 5L | (1L << 63):
        supervisorTimer();
        break;  
        5是时钟中断，1L << 63 是什么？

---

# 第三章

- [ ] 3.4 测试 
  - [x] initMemory()  extern void initHeap(); initHeap(); 有两个initHeap() 核对一下（第一个为声明一个外部函数，第二个才调用）
  - [ ] ***** Init Interrupt *****
***** Init Memory *****
alloc 0x0000000080b23000
alloc 0x0000000080b24000
alloc 0x0000000080b25000
dealloc 0x0000000080b24000
alloc 0x0000000080b24000
alloc 0x0000000080b26000

这里的地址能否增加一些说明，把物理内存现在整个的分布大致说明一下，为什么从**0x80b23000** 开始，跟下面这段代码开始的地址什么关系？程序加载需要多大？分配在哪？如果作为实验内容，这里能问出点什么问题?


``` C
// kernel/memory.h

extern void kernel_end();

// 页/帧大小
#define PAGE_SIZE 4096

// 可以访问的内存区域起始地址
#define MEMORY_START_PADDR 0x80000000

// 可以访问的内存区域结束地址
#define MEMORY_END_PADDR 0x88000000

// 内核起始的物理地址
#define KERNEL_BEGIN_PADDR 0x80200000

// 内核起始的虚拟地址
#define KERNEL_BEGIN_VADDR 0x80200000
```
---

# 第四章

- [ ] 4.2 测试 
  - [ ] kernel/entry.asm 每一行都加上注释，画一个内存分布图，页表被存的位置
  - [ ] 能否增加一个调试内容，申请一页，页表变化，把页表打印出来
- [ ] 4.3 实现页表 
  - [ ] 这里能不能通过一个具体的例子，然后配上示意图，把转换之间的关系表述明白，然后再去看代码，代码对于初学者还是过于抽象了 
- [ ] 4.4 重新映射内核 
  - [ ] 这里，最好能把映射前后内存分布对照着画出来，这样就会清晰很多

---

# 第五章

- [ ] 5.1 

这里对照着x86是有不同的地方，切换时，区分哪部分是硬件完成，哪部分是OS完成？这可以在系统框架里，把这部分完成，说明白 

``` C
// kernel/context.h

// 线程运行上下文
typedef struct {
    usize ra;
    usize satp;
    usize s[12];
    InterruptContext ic;
} ThreadContext;
```

- [ ] 5.2 

``` C 
// kernel/thread.c

__attribute__((naked, noinline)) void
switchContext(usize *self, usize *target)
{
    asm volatile(".include \"kernel/switch.asm\"");
}
```
> 这里使用了两个属性，naked 表示不要在这个函数执行前后加入任何的开场白（prologue）和结语（epilogue），通常的编译器会根据函数调用约定，在函数开头自动加入保存寄存器、设置栈寄存器等内容，这部分我们自行来设置。

像这种用法，对C语言的初级掌握者就挺有挑战，在基础章节那里加一小节，专门介绍和汇总这些用法

  - [ ]
``` C 
.equ XLENB, 8

    addi  sp, sp, (-XLENB*14)
    sd sp, 0(a0)
    sd ra, 0*XLENB(sp)
    sd s0, 2*XLENB(sp)
   
    ...
```
这一段保存了14个信息，ThreadContext结构体中还有别的选项，虽然之前已经提过一次，这里最好再强调一下

  - 程序最后的 `ret` 还有类似的  `sret`  `mret` ，返回时硬件做了什么？怎么跳回到原程序的，稍微介绍一些。

- [ ] 5.3 构造线程结构

> 由于我们已经将完整的 ThreadContext 压栈，待 switchContext() 执行完成返回时，会自动回收 ra、satp 和 s0 ~ s11，栈顶只剩下一个 InterruptContext，这种情况恰好和从中断处理函数返回时是类似的情况！ra 的值被设置为 __restore()，就正是为了借用中断返回机制来初始化线程的一些寄存器，如传参等。从 __restore() 返回就会跳转到 InterruptContext 的 sepc 位置，这正是线程的入口点，同时栈顶指针 sp 也被正确地设置为 kernelStackTop。

这个位置需要好好介绍一下，这里是重点，画个示意图，切换前后，哪些重要的寄存器变化了

``` C 
usize
newKernelThreadContext(usize entry, usize kernelStackTop, usize satp)
{
    InterruptContext ic;
    ic.x[2] = kernelStackTop;
    ic.sepc = entry;
    ic.sstatus = r_sstatus();
    ic.sstatus |= SSTATUS_SPP;
    ic.sstatus |= SSTATUS_SPIE;
    ic.sstatus &= ~SSTATUS_SIE;
    ThreadContext tc;
    extern void __restore(); tc.ra = (usize)__restore;
    tc.satp = satp;
    tc.ic = ic;
    return pushContextToStack(tc, kernelStackTop);
}
```

像这段代码，每一行加上注释，`|=` `&=` 等等给予说明
再有像这段代码，做了几件事，输入输出等，参照一些代码注释规范

- [ ] 5.4 从启动线程到新线程
  - [ ] 这些函数名能不能有个什么标准，例如POSIX有关线程的一些名字，包括参数名，感觉现在起的有点随意
  - [ ] 再有两个线程切换之前，在内存的分布情况，包括已经保留的各个特殊的寄存器的值，切换的时候，两套线程的上下文的值变化的情况，如何跟踪查看。简单点说，怎么能在不看代码细节的情况下，把切换过程，先想明白，通过示意图和跟踪的值把这个过程描述清楚 


---

# 第六章 线程管理

- [ ] 6.1 线程管理
  - [ ] 线程池 下面的代码，没对齐，调整一下格式

- [ ] 6.2 调度线程
  - [ ] 调度线程的中断下面这段代码，凡是出现汇编的地方都要加上注释
  - [ ] 更好的写法，例如，这里给出一个sstatus寄存器的图，改的是哪几位，改动前后分别是什么值一目了然
  
- [ ] 6.3 Round-Robin 调度算法
  - [ ] 这里是不是可以设计一下，用不同的算法进行实验，你这里写个简要的实验指导书吧，具体算法思想是什么，上课都讲过，也可以查询wiki，实现的时候注意什么？大概分几个步骤？如何验证或测试？

---

# 第七章 用户进程

- [ ] risc-v里进程和线程的关系？x86那里直接先讲的进程，包括作为资源分配的单位，可以申请空间，栈等。risc-v里进程和线程的关系在前面哪里单独介绍一下吧，有点模糊。寄存器 x4 thread pointer ，为什么单独有这么个寄存器，没有进程的，可以探讨的深入一些，肯定有这么设计的道理

---

# 第八章 文件系统

- [ ] 这章多一些流程图或是解释操作的示意图，代码多了以后，调理就不那么清晰了
- [ ] 这里是不是也可以让能力稍强一点的同学，实现一个别的文件系统

---

# 第九章 文件系统

- [ ] 9.1 键盘中断这里可以给几个图，把原理大概阐明一下，大体步骤，然后需要设置什么，最好画出相应寄存器，对照着看，一下就知道了。其实这里需要设置一堆标志位一类，这种东西，繁琐，而且就是规定，照着做就行，重点把逻辑写明白就好
- [ ] 9.1 “还可以直接使用 OpenSBI 的服务 CONSOLE_GETCHAR，就能读取到输入的字符了”，说一下为什么使用OpenSBI 而不是自己写
- [ ] 9.2 缓冲的过程画个示意图，详细解释一下，缓冲到哪？怎么读取缓冲？什么时候读？读多少？

---


# 整体问题
  - 其实你这里已经实现了从启动到线程创建，再到线程切换，但是，这里介绍的整体性不够，我的意思是，启动是在内核态，如何跳到创建的用户线程，线程切换时，控制权应该交还给内核，再切换到另一线程，类似我上课讲的linux 0.00，这里除了介绍必要的切换的细节，还有就是优先级如何跳转的，这里应该多写一些。
  - 再有配上图，把整个过程介绍清楚，特别要介绍，在各种切换，优先级转换，跳转，返回等，硬件做了什么，这对于程序员是不可见的，也是编写操作系统的难点，不理解这里面的过程和细节，就没办法编写程序
  - 还有关于栈的介绍。通用寄存里有一个栈指针寄存器，保存用户栈，但当放生特权级转换时，进入到内核态，用户态时的栈指针等通用寄存器被作为上下文被压入到“什么”栈里？内核栈？每个用户线程都有各自内核栈？因为我没跟踪程序，这里我没太想明白。上下文保存与恢复借助了栈，这个没问题。但是系统调用时，进入内核后用的栈是什么时候创建的，栈指针是什么时候，怎么初始的？（之后我才看到7.3的最后有些介绍）
  - 代码加注释，多加示意图和流程图，参照上面每章具体意见

# 建议
- 能不能仿照linux0.00，用risc-v 纯汇编写个一样的程序，直接写好打印A，B的两个程序放在内存里，然后，从启动，到时钟中断，到打印调用，伴随着栈切换，进程切换等等，这样可以把所有设计特权模式下的东西都解释了，可以配合着最前面放的章节一起把有关内容就介绍了
- 个人感觉，所有机理你都懂了，而且已写过相应代码，包括汇编也都很熟悉，我觉得你很快就能写出来，加油！