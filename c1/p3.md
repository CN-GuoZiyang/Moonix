# 使用 QEMU 运行

----

# 加载镜像

使用如下命令启动 QEMU 并加载镜像：

```bash
$ qemu-system-riscv64 
		-machine virt \
		-bios default \
		-device loader,file=Image,addr=0x80200000 \
		--nographic

OpenSBI v0.6
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Platform Max HARTs     : 8
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 120 KB
Runtime SBI Version    : 0.2

MIDELEG : 0x0000000000000222
MEDELEG : 0x000000000000b109
PMP0    : 0x0000000080000000-0x000000008001ffff (A)
PMP1    : 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
```

较新版本的 QEMU 内置了 OpenSBI，通过 `-bios` 指定 Bootloader 为 default 时默认使用为 OpenSBI。`--device loader` 表示将后面的内容直接加载到内存中的某个地址处，并不做其他动作。这里我们加载的文件为 Image，加载到 0x80200000，正好和 Image 内部的地址对上了。

运行结果和我们在安装环境时的测试结果一样，这是因为我们的 kernel 除了一个忙循环外什么都没有做。我们会在下一节让内核输出点什么，来验证我们**真的**把内核加载进去了。

# Makefile 自动化编译

现在仅仅是一个文件的编译就需要四五条语句，到后期文件很多的时候编译工作会十分繁琐，我们可以使用 Makefile 来简化这一过程。

```makefile
# Makefile

K=kernel

# 后续添加的源文件需要在这里添加，否则不会参与连接
OBJS = 						\
	$K/main.o

# 设置交叉编译工具链
TOOLPREFIX := riscv64-linux-gnu-
CC = $(TOOLPREFIX)gcc
AS = $(TOOLPREFIX)gas
LD = $(TOOLPREFIX)ld
OBJCOPY = $(TOOLPREFIX)objcopy
OBJDUMP = $(TOOLPREFIX)objdump

# QEMU 虚拟机
QEMU = qemu-system-riscv64

# gcc 编译选项
CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb
CFLAGS += -MD
CFLAGS += -mcmodel=medany
CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax
CFLAGS += -I.
CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)

# ld 链接选项
LDFLAGS = -z max-page-size=4096

# QEMU 启动选项
QEMUOPTS = -machine virt -bios default -device loader,file=Image,addr=0x80200000 --nographic

all: Image

Image: Kernel

Kernel: $(subst .c,.o,$(wildcard $K/*.c))
	$(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/Kernel $(OBJS)
	$(OBJCOPY) $K/Kernel -O binary Image

# compile all .c file to .o file
$K/%.o: $K/%.c
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	rm -f */*.d */*.o $K/Kernel Image Image.asm
	
asm: Kernel
	$(OBJDUMP) -S $K/Kernel > Image.asm

qemu: Image
	$(QEMU) $(QEMUOPTS)
```

`make Image` 命令可以生成内核镜像，`make clean` 可以清理编译的文件，`make asm` 可以生成内核的反汇编文件，`make qemu` 可以直接从 QEMU 加载内核启动。

注意，以后我们每添加一个 .c 文件都需要在 OBJS 中加入，否则这个文件就不会参与链接。

同时整理一下文件，将所有的除了 Makefile 以外的文件全都放到 kernel 文件夹中。

这里不会详细讲解 Makefile，有兴趣的话可以自行研究。