# 6.4 调度测试

----

我们完成了所有的部分，终于可以开始测试了。

我们计划创建一些线程，线程的入口点是这个函数：

```c
// kernel/thread.c

void
helloThread(usize arg)
{
    printf("Begin of thread %d\n", arg);
    int i;
    for(i = 0; i < 800; i ++) {
        printf("%d", arg);
    }
    printf("\nEnd of thread %d\n", arg);
    exitFromCPU(0);
    while(1) {}
}
```

会将传入的参数输出 800 遍，之后调用 `exitFromCPU()` 退出。

初始化线程主要分为一下步骤：

1. 创建调度函数实现
2. 创建线程池
3. 构造 idle 函数
4. 初始化 CPU
5. 构造线程并添加到 CPU 中
6. 启动

实现如下：

```c
// kernel/thread.c

void
initThread()
{
    Scheduler s = {
        schedulerInit,
        schedulerPush,
        schedulerPop,
        schedulerTick,
        schedulerExit
    };
    s.init();
    ThreadPool pool = newThreadPool(s);
    Thread idle = newKernelThread((usize)idleMain);
    initCPU(idle, pool);
    usize i;
    for(i = 0; i < 5; i ++) {
        Thread t = newKernelThread((usize)helloThread);
        usize args[8];
        args[0] = i;
        appendArguments(t, args);
        addToCPU(t);
    }
    printf("***** init thread *****\n");
}
```

这里循环创建了五个线程，并传入循环变量 i 作为参数。

我们启动一下：

```bash
Welcome to Moonix!
***** Init Interrupt *****
***** Init Memory *****
***** Remap Kernel *****
***** init thread *****

>>>> will switch_to thread 0 in idle_main!
Begin of thread 0
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
End of thread 0
Thread 0 exited, exit code = 0
<<<< switch_back to idle in idle_main!

>>>> will switch_to thread 1 in idle_main!
Begin of thread 1
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
End of thread 1
Thread 1 exited, exit code = 0
<<<< switch_back to idle in idle_main!

>>>> will switch_to thread 2 in idle_main!
Begin of thread 2
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222<<<< switch_back to idle in idle_main!

>>>> will switch_to thread 3 in idle_main!
Begin of thread 3
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
End of thread 3
Thread 3 exited, exit code = 0
<<<< switch_back to idle in idle_main!

>>>> will switch_to thread 4 in idle_main!
Begin of thread 4
44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444
End of thread 4
Thread 4 exited, exit code = 0
<<<< switch_back to idle in idle_main!

>>>> will switch_to thread 2 in idle_main!
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
End of thread 2
Thread 2 exited, exit code = 0
<<<< switch_back to idle in idle_main!
** 100 ticks **
** 200 ticks **
....
```

你的输出可能与我不完全一样，但是可以看出，线程 2 在第一次运行时没有来得及运行结束，就被切换到线程 3 了，在线程 4 运行结束后，线程 2 又被调度占用了 CPU 才运行结束。